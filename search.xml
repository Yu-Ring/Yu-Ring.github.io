<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>背包问题导论</title>
      <link href="/2023/03/22/5.0-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/22/5.0-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>背包问题</strong></p><blockquote><p>从N个物品中选取放入到容量为M的背包中，每个物品价值$w_i$ 体积$v_i$，要求背包中价值最大</p></blockquote><p><strong>01背包</strong>[[5.1-01背包问题]]</p><blockquote><p>每件物品只能用一次</p></blockquote><p><strong>完全背包</strong>[[5.2-完全背包问题]]</p><blockquote><p>每件物品无限个</p></blockquote><p><strong>多重背包</strong>[[5.3-多重背包]]</p><blockquote><p>每件物品可用次数不同</p></blockquote><p><strong>分组背包</strong>[[5.4-分组背包]]</p><blockquote><p>n组物品，每组若干，每组只可选一个 </p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01背包问题</title>
      <link href="/2023/03/22/5.1-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/22/5.1-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230212144947.png|600]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>先从小规模的问题出发，寻找本质</strong></p><blockquote><p>设 背包容量$V$, 第 $i$ 件物品体积 $v_i$ 价值$w_i$<br>问题1：$V&#x3D;10;v_1&#x3D;4,w_1&#x3D;5;$<br>问题2：$V&#x3D;10;v_1&#x3D;4,w_1&#x3D;5;v_2&#x3D;5,w_2&#x3D;6$<br>问题3：$V&#x3D;10;v_1&#x3D;4,w_1&#x3D;5;v_2&#x3D;5,w_2&#x3D;6;v_3&#x3D;6,w_3&#x3D;7;$</p></blockquote><blockquote><p>问题1涉及到是否要选择物品1<br>问题2在选完了物品2后，就回到了问题1上，但此时场景为$V&#x3D;5$<br>同理，问题3选择物品后会回到问题1，问题2两个<strong>子问题</strong>上，只是场景不同</p></blockquote><blockquote><p>&#x3D;&#x3D;问题具有<strong>重叠子问题</strong>的性质。随着我们的选择，总是能遇到相应状态的子问题。&#x3D;&#x3D;<br>&#x3D;&#x3D;想求当前问题的最优解，就需要去保证子问题的最优解，因此他具备<strong>最优子结构的性质</strong>。&#x3D;&#x3D;<br>&#x3D;&#x3D;只面对物品1时的最优解，并不受物品2的影响。所以它也<strong>具备无后效性</strong>的性质。&#x3D;&#x3D;</p></blockquote><p>我们利用一个二维数组来存储问题，从最小的子问题一次一次增大规模，大规模问题可以直接获取已经解决的子问题的答案。</p><h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h3><p>动态规划需要我们<strong>提前记录好各个子问题的解</strong>，便于我们后续大规模问题的调用。</p><blockquote><p>1、不同子问题之间的转换关系（<strong>状态方程的表示</strong>）<br>2、如何有顺序地扩大子问题规模（<strong>循环的书写</strong>）</p></blockquote><h4 id="（1）状态方程"><a href="#（1）状态方程" class="headerlink" title="（1）状态方程"></a>（1）状态方程</h4><ul><li><p><strong>a.状态表示：</strong><br>假设物品选择规模是i个，此时的背包容量是j，那么可以将当前的问题状态表示为：<code>f(i,j)</code></p><blockquote><p>  $f(i,j)$:当面前共有i个物品，背包容量为j时，我们所能携带的最大价值。</p></blockquote></li><li><p><strong>b.状态转移</strong><br>状态转移就是表示出当前问题和子问题之间的关系。<br><strong>状态转移方程</strong>的书写思路就是：<strong>活在当下</strong>：通过当前的决策将问题的规模减少。 </p><blockquote><p>第 $i$ 物品的价值记作 $w[i]$ ,物品的体积记作 $v[i]$ 。</p></blockquote></li></ul><p>我们遇到了第i个物品，所以我们当下的事情第i个物品选或者不选。<br>两种情况下的最大值，就是我们的 $f(i,j)$ 的解。</p><blockquote><p>假设我们不选，那么此时的状态就只需要面对$i-1$个物品，背包容量也没变，即 $f(i-1,j)$<br>如果我们选了，那么此时的状态也只需要面对$i-1$个物品，但此时的容量和价值发生改变。</p></blockquote><p><strong>转移方程</strong> ：![[Pasted image 20230212155050.png|450]]</p><ul><li><strong>二维数组角度上看</strong> 本质就是一个&#x3D;&#x3D;枚举每一个点 $(i,j)$&#x3D;&#x3D; 一层层向上爬，直到走到第一行。<br><em>可移动范围就是左上，而上方&#x3D;&#x3D;(包括右上)&#x3D;&#x3D;所有的路都有计算过</em></li></ul><h4 id="（2）循环的设计"><a href="#（2）循环的设计" class="headerlink" title="（2）循环的设计"></a>（2）循环的设计</h4><blockquote><p>循环设计是为了<strong>能够及时计算出后续问题需要的子问题结果</strong>，并有序地存储起来。<br>以分析为例，后续问题中最后的子问题永远是第一个物品的选择，但面对第一个物品时容量不同。<br>因此可以<strong>先枚举出不同容量下，面对第一个物品的最优解</strong>。<br>然后<strong>再枚举同时面对第1，2个物品时，不同容量下的最优解</strong>。<br>以此类推…</p></blockquote><h2 id="朴素代码"><a href="#朴素代码" class="headerlink" title="朴素代码"></a>朴素代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],v[N],w[N];<span class="comment">// 转移方程 物品数量 物品价值</span></span><br><span class="line"><span class="type">int</span> n,m;<span class="comment">// 物品个数 背包容量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,v+i,w+i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举背包规模 显然f(0,0~m)都为0，无需初始化，从1开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)<span class="comment">//枚举对象相同，但不同容量情况的选法0~m</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//书写状态方程</span></span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j]; <span class="comment">//不选i时的f的价值最大值</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i]) <span class="comment">//选i时判断剩余容量</span></span><br><span class="line">            f[i][j]=max(f[i<span class="number">-1</span>][j-v[i]]+w[i],f[i][j]); <span class="comment">//选i和不选i的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空间优化代码"><a href="#空间优化代码" class="headerlink" title="空间优化代码"></a>空间优化代码</h2><p><strong>如何节省&#x3D;&#x3D;空间&#x3D;&#x3D;</strong></p><blockquote><p>二维数组角度上看，首先就第一层来说，由于并不知道下面的点走到上面时j会减少到多少，至多m<br><strong>因此 j 从 0~m 都需要遍历</strong><br>由于元素是一层一层往上走的，加上每次用都是上一行的元素，只需要 选择$v_i$ $w_i$变量。<br><strong>本质就是走n次</strong><br>由于当前问题的子问题都存储在了二维数组的上一行，再往上的子问题记录就没有用了，只是多占空间而已。<br>只需要一个<strong>一维数组</strong>。只需要<strong>来回覆盖</strong>。 就可以代替原来的二维数组。</p></blockquote><p>使用的空间如下（<em>看个大概就行</em>）：![[FC77CAA98F0C3C8F13FE9F665D2E1EE2.png|550]]<br><em>选择第$i$个物品就是跳格子斜走，不选就只是上移</em></p><blockquote><p><strong>用一个长度为m的一维dp数组 $f[j]$ $表示当前的背包容量为j时的价值$</strong></p></blockquote><blockquote><p>而一维数组有限，<strong>只有需要选择当前物品的格子，会有j和f值的变动</strong>，<strong>不选j和f都不变</strong><br>意思就是说$j &gt;&#x3D; v_i$都会更新,而 $j&lt;v_i$ 都不需要更新<br>不妨让背包从一开始就是容量最大，每行枚举左走，走到当背包容量不够$v_i$就下一行。(不选不需要更新)<br>所以我们采取<strong>逆序覆盖</strong>。</p></blockquote><blockquote><p>如果采取正序覆盖, <strong>$j$ 从0开始一直到 $v_i$ 都不需要更新</strong>。<br>同时从二维数组来看，由于当前格$(i,j)$如果要更新必定会用到上一行左侧的某个元素，而放在一维数组中，同时由于是正序，当前要处理的元素左侧都已经被覆盖过了,<em>覆盖后对应二维(i,1~j-1)</em> 而我们更新需要用到的是覆盖前第$i-1$行的这些元素，<strong>从左开始会把更新需要用到的元素提前覆盖掉</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;<span class="comment">//物品数量 背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,v+i,w+i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举背包规模</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)<span class="comment">//枚举容量</span></span><br><span class="line">            f[j]=max(f[j-v[i]]+w[i],f[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>状态压缩DP</title>
      <link href="/2023/03/22/5.10-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
      <url>/2023/03/22/5.10-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/</url>
      
        <content type="html"><![CDATA[<h1 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230219154005.png|500]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>注意到，只要放好横着的方块，竖着的方块的放法是唯一确定的，因此<strong>只需要考虑横放的方块</strong>。<strong>总方案数等于只放横着的小方块的合法方案数。</strong></p></blockquote><p>动规的核心思路就是<strong>枚举子问题</strong></p><blockquote><p>![[6490208E1CE264C5BE73433A05DBC0E5.png|300]]<br>让列数从小到大增大，列数较小的看作子问题。<br><em><strong>横放的方块看作，当前列的某几行延申到了下一列</strong></em><br><strong>注意</strong>：<strong>不可连续延申2次</strong>出现$1*3$方块的情况，同时<strong>两个横方块间行数需为偶</strong>防止竖块无法填满</p></blockquote><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态压缩</strong> :<strong>将一种状态压缩成二进制数</strong> 规定：1代表延申，0代表不延申。</p><blockquote><p>![[Pasted image 20230219164243.png|300x300]]<br>将上图中的<strong>一种状态压缩成了一个十进制数字 j</strong> 所以$j$ 就表示表格中的延申状态.<br>假设行数是5行，只需要从$00000$到$11111$去枚举每一种状态，然后我们判断是否合法即可。<br>而中间的状态枚举，即$j$ 写一个循环$0\sim2^5-1$<br>(<strong>所有状态：</strong> $000\dots00 \sim 111\dots11$)  <code>i = 0; i &lt; 1&lt;&lt;n ;i++</code><br>注意：*$j$不可以有连续奇数个0*；</p></blockquote><p><strong>状态表示：</strong> $$f[i][j]\ :第i列向第i+1列延申为j状态，至此i列所有方案数。$$</p><blockquote><p>最终状态：假设表格有k列，那么最终表示就是$f[k][0]$，意思就是第k列不延申到下一列。</p></blockquote><blockquote><p>就$i$列来看,$i-1$延申到$i$的状态表示为$k$, $i$到$i+1$为$j$,为避免$1<em>3$格子,<strong>要保证$k !&#x3D; j$</strong><br>同时要*<em>保证j的二进制数中不可以有奇数个0</em></em></p></blockquote><p><strong>状态转移：</strong>$$f[i][j]&#x3D;f[i][j]\  +\  f[i-1][k]$$</p><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><blockquote><p>外循环就是列数，内循环就是每一列可能的延申情况。<br>结束时输出$f[m][0]$ ：到达最后一列，并不再继续横放延申</p></blockquote><p><strong>初始化</strong>：</p><blockquote><p>事实从第1列开始枚举，但第1列判断冲突需要前一列，且一定不冲突，所以$i&#x3D;0;j&#x3D;0$ ;<br>$f[0][0]&#x3D;1$</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">15</span>,M=<span class="number">1</span>&lt;&lt;N;<span class="comment">//列数  状态数2^N个</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[N][M];<span class="comment">// 当前为第i列 状态为j 目前所有i列记录的方案数 </span></span><br><span class="line"><span class="type">bool</span> st[M];<span class="comment">//此状态是否合法</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m,n||m)<span class="comment">//不断输入棋盘行列大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; <span class="number">1</span>&lt;&lt;n;i++)<span class="comment">//遍历所有状态检查是否存在连续奇数个0</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//当前状态连续0的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j &lt; n;j++)<span class="comment">//n行，检查某列n个元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)<span class="comment">//当前位是1,连续0断开,进行一次连续0判断</span></span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) st[i]=<span class="literal">false</span>;<span class="comment">//连续奇数个0不合法</span></span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++;<span class="comment">//连续0，cnt加一</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) st[i]=<span class="literal">false</span>;<span class="comment">// 都到结尾，进行一次连续0判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">// 第1列开始，第0列只是虚构服务第1列，无方案不冲突，初始1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="comment">// 枚举所有共m列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt; <span class="number">1</span>&lt;&lt;n;j++) <span class="comment">// 枚举i列延申到i+1列所有状态</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt; <span class="number">1</span>&lt;&lt;n;k++) <span class="comment">// i-1列延申到i列所有状态</span></span><br><span class="line">                    <span class="keyword">if</span>(!(j&amp;k)&amp;&amp;st[j|k]) <span class="comment">// 如果j k不冲突 且 连续0合法</span></span><br><span class="line">                    dp[i][j]+=dp[i<span class="number">-1</span>][k];<span class="comment">// 该方案可下一列继续</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[m][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//到最后一列不应该再向外延伸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230220085230.png|500]]</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><blockquote><p>汉密尔顿图：经过每个节点恰好一次</p></blockquote><blockquote><p>我们求最短路是通过<strong>松弛</strong>操作进行的，就对一条走完所有点的路径而言，最后一个点为j，倒数第二个点为k，我们已知$w[j][k]$，并尝试逆推往回求出0到k的最短路径。<strong>不断反向递归</strong>，直到路径只有2个点走过时，k只能表示0本身，0到k的最短路径不言而喻。<em>事实上是贪心思想</em></p></blockquote><h3 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong>——状态压缩</p><blockquote><p>有一个变量$j$ 表示当前状态到达的点，<br>到达$j$点时经过的点的记录$i$ ，防止漏点或重复，利用二进制数$i$表示路径$$f(i,j):到达点j时通过路径为i的最短路径长度$$<br>二进制表示000…00 ~ 111…11 走完为止 即<code>i = 0; i &lt; 1&lt;&lt;n ;i++</code><br><em>e.g. 比如走过了 0，1，5，4号点 共 8个点 则为00110011</em></p></blockquote><p><strong>状态转移</strong></p><blockquote><p>设k为j的前一个点，$w(0,j)&#x3D;w(0,k)+w(k,j)$ 其中$w(k,j)$固定，<br><strong>本质就是通过松弛找到0到k的最短路径：</strong><br>![[Pasted image 20230220230255.png|300]]$$f[i][j]&#x3D;min(f[i][j]\ ,\ f[i-(1\ll j)][k]+w[k][j])$$$i\gg j$表示路径中点$j$ 对应的二进制数位置显示情况，$i\gg j\  &amp; \ 1$表示$i$记录的路径中是否经过$j$<br>$i−(1\ll j)$表示当前路中$j$点去掉的路径。k应该是当前走过路径的非j点，防止k会表示j</p></blockquote><h3 id="循环设计-1"><a href="#循环设计-1" class="headerlink" title="循环设计"></a>循环设计</h3><blockquote><p>由于最终的路径需要之前走过路的信息，所以<strong>没走完所有点的路径也需要<em>顺序</em>枚举</strong><br>对于某个路径，只能表示走过那些点，但并不知道最后一个是谁，所以<strong>路径内除了起点以外的所有点都要枚举</strong><br>同样的，松弛操作需要的倒数第二个点也不知道，<strong>除了0，j之外走过的其他点也需要枚举</strong></p></blockquote><blockquote><p>枚举所有路径，枚举该路径中已有的所有点j，（枚举）利用路径上其他点k，寻找0k最短路</p></blockquote><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">21</span>,M=<span class="number">1</span>&lt;&lt;N;</span><br><span class="line"><span class="type">int</span> f[M][N],g[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            cin&gt;&gt;g[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//从0走到0，0号点上二进制表示为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; <span class="number">1</span>&lt;&lt;n;i++)<span class="comment">//枚举所有路径情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)<span class="comment">//尝试枚举所有n个节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;&gt;j &amp; <span class="number">1</span>)<span class="comment">//如果这个点在这条路中</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)<span class="comment">//枚举路径中其他点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>((i-(<span class="number">1</span>&lt;&lt;j))&gt;&gt;k&amp;<span class="number">1</span>)</span><br><span class="line">                    &#123;<span class="comment">//找到0到k的最短路径</span></span><br><span class="line">                        f[i][j]=<span class="built_in">min</span>(f[i][j],f[i-(<span class="number">1</span>&lt;&lt;j)][k]+g[k][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][n<span class="number">-1</span>]&lt;&lt;endl;<span class="comment">//所有点都走完，且终点在n-1的那条路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树形DP</title>
      <link href="/2023/03/22/5.11-%E6%A0%91%E5%BD%A2DP/"/>
      <url>/2023/03/22/5.11-%E6%A0%91%E5%BD%A2DP/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230223190907.png|600]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于每个树的根节点，该问题可以转化为以该节点的子节点为根节点的子树的相同问题</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong></p><blockquote><p>$$f[u][1]：表示从所有以u为根节点的子树中选，并且选择u时的最大数值 $$$$f[u][0]：表示从所有以u为根节点的子树中选，并且不选择u时的最大数值$$</p></blockquote><p><strong>状态转移</strong><br>设父节点为$u$ 子节点为$s_i$<br>如果不选择u。那么子节点$s_i$可选或不选<br>如果选择u，子节点$s_i$都不可以选</p><blockquote><p>$$f(u,0) &#x3D; \sum\limits {max(f(s_i, 0) , f(s_i,1))}$$$$f(u,1) &#x3D; \sum\limits {f(s_i, 0)}$$</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;<span class="comment">//邻接表存树</span></span><br><span class="line"><span class="type">int</span> hap[N];<span class="comment">//每个人的高兴值</span></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    f[u][<span class="number">1</span>]=hap[u];<span class="comment">//选根节点 加上该节点的高兴度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];<span class="comment">// 子节点</span></span><br><span class="line">        dfs(j);</span><br><span class="line">        f[u][<span class="number">0</span>]+=max(f[j][<span class="number">1</span>],f[j][<span class="number">0</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>]+=f[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//读入每个人的高兴度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;hap[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//初始化邻接表表头</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> root=<span class="number">1</span>;<span class="comment">//默认1为根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )<span class="comment">//读入所有边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<span class="comment">//子节点——父节点</span></span><br><span class="line">        add(b, a);</span><br><span class="line">        <span class="keyword">if</span>(a==root)root=b;<span class="comment">//替换父节点为根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(root);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;max(f[root][<span class="number">0</span>],f[root][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记忆化搜索</title>
      <link href="/2023/03/22/5.12-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
      <url>/2023/03/22/5.12-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230226132434.png|650]]<br>![[Pasted image 20230226132517.png|650]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于一条最优路径<code>a--&gt;b--&gt;c--&gt;d--&gt;y--&gt;x--&gt;i--&gt;d</code><br>可以从子最优路径<code>b--&gt;c--&gt;d--&gt;y--&gt;x--&gt;i--&gt;d</code> 直接得到，无需重复搜索<br>采用<strong>记忆化搜索</strong> </p><blockquote><p>直接记录搜索过的点所能达到的最大路程。<br>如果遇到相同的点，我们就直接返回我们记录的数据，终止重复搜索。</p></blockquote><p>$$f[i][j]:表示以(i,j)为起点的路径长度$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> h[N][N]; <span class="comment">// 每个点的高度</span></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    </span><br><span class="line">    f[x][y]=<span class="number">1</span>;<span class="comment">//默认每个点都是终点，不可走至少为1格，反向寻找最长路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++ )<span class="comment">//枚举四个方向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a= x + dx[i],b = y + dy[i];</span><br><span class="line">        <span class="comment">//如果在界内 且 高度比当前小（可走）</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt;= <span class="number">1</span> &amp;&amp; a &lt;= n &amp;&amp; b &gt;= <span class="number">1</span> &amp;&amp; b &lt;= m &amp;&amp; h[a][b] &lt; h[x][y])</span><br><span class="line">        f[x][y]=max(f[x][y], dfs(a,b) + <span class="number">1</span>);<span class="comment">//不走和走之间的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//输入每个点高度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);<span class="comment">//每个点-1都未算过</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//遍历每个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            res=max(res,dfs(i,j));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>完全背包问题</title>
      <link href="/2023/03/22/5.2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/22/5.2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230214234400.png|600]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><blockquote><p>相比01背包，完全背包中同一物品可以选择多次，仅受限于背包容量。01背包中，分为选i或者不选；而完全背包中可以划分更多区域：选0个，选1个，选2个，选3个… 选k个<br>这道题符合动态规划的三个性质：<strong>最优子结构</strong>，<strong>重叠子问题</strong>，<strong>无后效性</strong>。</p></blockquote><h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h3><blockquote><p>1、构建当前问题和子问题之间的关系：书写<strong>状态转移方程</strong>。<br>2、<strong>设计循环</strong>，记录每一个子问题的最优解</p></blockquote><h4 id="1、状态转移方程"><a href="#1、状态转移方程" class="headerlink" title="1、状态转移方程"></a>1、状态转移方程</h4><blockquote><p>要做的选择就是第i个物品，你到底是选还是不选，&#x3D;&#x3D;选几个&#x3D;&#x3D;。</p></blockquote><ul><li><strong>状态转移方程</strong>![[Pasted image 20230214234827.png|500]]</li></ul><h4 id="2、循环设计"><a href="#2、循环设计" class="headerlink" title="2、循环设计"></a>2、循环设计</h4><blockquote><p>循环的设计其实就是为了有条不紊地逐渐计算出规模不断增大地子问题。完全背包的循环设计和01背包的循环设计是一致的。我们逐一枚举1个物品时，各个容量下的最优解，2个物品时，各个容量下的最优解，直到n个物品下，各个容量下的最优解。</p></blockquote><h2 id="朴素代码"><a href="#朴素代码" class="headerlink" title="朴素代码"></a>朴素代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,v+i,w+i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)<span class="comment">//枚举不同剩余容量的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k*v[i]&lt;=j;k++)<span class="comment">//书写状态方程，每一种情况下选择数量</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+w[i]*k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间-空间优化代码"><a href="#时间-空间优化代码" class="headerlink" title="时间+空间优化代码"></a>时间+空间优化代码</h2><h3 id="（1）时间优化"><a href="#（1）时间优化" class="headerlink" title="（1）时间优化"></a>（1）时间优化</h3><blockquote><p>完全背包问题依旧是只利用 $i-1$ 行的数据</p></blockquote><blockquote><p>就状态转移方程而言<br> $f[i][j]&#x3D;f[i-1,j-v_i<em>k]+w_i</em>k$<br> ![[Pasted image 20230215234104.png|600]]<br> 第一行从第2个开始的每一项都和第二行的第1个开始的每一项对应，但彼此间大小不变<br> 即<strong>如果第一行的最大值确定为为$j-r<em>v$ $(r&gt;&#x3D;2)$项,则第二行最大值也为$j-r</em>v$项</strong></p></blockquote><blockquote><p>而$j$是从小到大遍历，所以第二行一定在第一行之前就得出后几项的最大值，所以<strong>可以省略k的遍历</strong><br>即本行的最佳策略在上一行子问题已经得到解决。</p></blockquote><p><strong>时间优化：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1100</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,v+i,w+i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i])</span><br><span class="line">            f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对比</strong></p><blockquote><p><strong>01背包：</strong>![[Pasted image 20230215235358.png|250]]<br><strong>完全背包：</strong>![[Pasted image 20230215235511.png|250]]<br>比较二者可以看出，<strong>完全背包</strong>面对$(i,j)$时，判断需要左上斜跳到$(i-1,j-v_i)$获取更新时，又由于$j$从小到大遍历，同行的$(i,j-v_i)$已经确定了物品数量的选择，所以跳到了&#x3D;&#x3D;同一行&#x3D;&#x3D;$(i,j-v_i)$<br>而<em>01背包</em>则是跳到了&#x3D;&#x3D;上一行&#x3D;&#x3D;$(i-1,j-v_i)$<br>考虑到<em>01背包优化空间</em>时$j$为<em>逆序覆盖</em>，综上又可以得出只需要&#x3D;&#x3D;<strong>正序覆盖</strong>&#x3D;&#x3D;就可以完成完全背包空间优化</p></blockquote><p><strong>进一步空间优化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,v+i,w+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)<span class="comment">//正序覆盖</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i])</span><br><span class="line">            f[j]=max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分组背包问题</title>
      <link href="/2023/03/22/5.4-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/"/>
      <url>/2023/03/22/5.4-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230216175210.png|600]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>n组物品，每组若干，&#x3D;&#x3D;每组只可选一个&#x3D;&#x3D; </p></blockquote><blockquote><p>这道题符合动态规划的三个性质：<strong>重叠子问题，最优子结构，无后效性</strong>。<br>因此，我们可以使用动态规划的思路去解决这道题。动态规划我们需要思考两个问题：<br><strong>1、状态转移方程的书写 2、循环的设计</strong></p></blockquote><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><blockquote><p>状态$f(i,j)$表示的是&#x3D;&#x3D;共有$i$ 组物品，此时我们的背包容量为$j$ 的时候，我们所能携带的最大价值&#x3D;&#x3D;<br>$v[i][k]$ $w[i][k]$表示的是第 $i$ 组·第$k$ 个物品的容量 价值</p></blockquote><p>![[Pasted image 20230216195649.png|500]]</p><h3 id="循环的设计"><a href="#循环的设计" class="headerlink" title="循环的设计"></a>循环的设计</h3><blockquote><p>这里的循环还是和其他背包问题的设计方式一样，我们的最外层循环的是，我们所面对的物品<strong>组数</strong>，第二层循环枚举的是我们的容量。然后书写我们的状态转移方程。</p></blockquote><h2 id="朴素代码"><a href="#朴素代码" class="headerlink" title="朴素代码"></a>朴素代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],v[N][N],w[N][N],s[N];<span class="comment">//最大价值 i组j号物品容量和价值 第i组物品个数</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;<span class="comment">//组数 背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,s+i); <span class="comment">// i组内物品个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i][j],&amp;w[i][j]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">// 枚举所有组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)<span class="comment">// 枚举所有背包容量</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s[i];k++)<span class="comment">// 枚举组内所有物品的编号</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i][k]&lt;=j)</span><br><span class="line">                f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空间优化代码"><a href="#空间优化代码" class="headerlink" title="空间优化代码"></a>空间优化代码</h2><blockquote><p>基于01背包的空间优化可以把$f[i][j]$ 优化成 $f[j]$ </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N],v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,s+i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i][j],&amp;w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)<span class="comment">//逆序覆盖</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s[i];k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i][k]&lt;=j)</span><br><span class="line">                f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多重背包问题</title>
      <link href="/2023/03/22/5.3-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
      <url>/2023/03/22/5.3-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230216134233.png|600]] </p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><blockquote><p>相比完全背包，多重背包对于物品的选择有一定的次数限制，每个物品最大可选上限不同。<br>但这道题符合动态规划的三个性质：<strong>最优子结构</strong>，<strong>重叠子问题</strong>，<strong>无后效性</strong>。</p></blockquote><h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h3><blockquote><p>1、构建当前问题和子问题之间的关系：书写<strong>状态转移方程</strong>。<br>2、<strong>设计循环</strong>，记录每一个子问题的最优解</p></blockquote><h4 id="1、状态转移方程"><a href="#1、状态转移方程" class="headerlink" title="1、状态转移方程"></a>1、状态转移方程</h4><blockquote><p>前面的两篇文章中介绍过，对于背包问题而言，一般用一个二维数组来表示dp数组，即经常写的$f(i,j)$ 当物品数量为$i$，背包容量是$j$的时候，我们所能携带的最大价值：$f[i][j]$。</p></blockquote><h4 id="2、循环设计"><a href="#2、循环设计" class="headerlink" title="2、循环设计"></a>2、循环设计</h4><blockquote><p><strong>状态转移的目的是为了能够将大规模的问题转化成较小规模的问题。</strong></p></blockquote><h2 id="朴素代码"><a href="#朴素代码" class="headerlink" title="朴素代码"></a>朴素代码</h2><p>和完全背包几乎没有区别，最后一层k的循环中值条件需要额外增加<code>q[i]</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],v[N],w[N],q[N];<span class="comment">//q[n]存储该物品可选数量最大值</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,v+i,w+i,q+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品规模</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)<span class="comment">//枚举背包容量</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k*v[i]&lt;=j&amp;&amp;k&lt;=q[i] ;k++)<span class="comment">//枚举所有可选数量</span></span><br><span class="line">            &#123;<span class="comment">//书写状态转移方程</span></span><br><span class="line">                f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><ul><li><p><strong>不能用完全背包的方法优化多重背包</strong></p><blockquote><p>在<strong>完全背包中</strong>，比较$f[i,j]$和$f[i,j-v_i]$ 时，max函数中的可列项<strong>完全取决于背包容量$j$</strong><br>所以$f[i,j]$的k+1项中除了第1项，后面k项和$f[i,j-v_i]$ 全部的k项对应<br><em>两者max函数各项：</em>![[Pasted image 20230216142146.png]]<br>但在<strong>多重背包中</strong>，max函数中的可列项<strong>同时还取决于物品 $i$ 可选上限 $s$</strong><br>也就是说，如果选取过程中$j$足够大,物品数量k先一步止步于s，那么$f[i,j]$ 和$f[i,j-v_i]$ 都是$s+1$项<br>错一位对应s项，会导致$f[i,j-v_i]$ 最后的s+1项多出来。</p><p>而$j$是递增迭代的，我们会先了解到$f[i,j-v_i]$中max函数s+1项中哪一项是最大的；等迭代到$f[i,j]$时我们需要用$f[i,j]$的max函数第1项和&#x3D;&#x3D;后面s项最大值比较&#x3D;&#x3D;，如果尝试借助$f[i,j-v_i]$中对应的前s项来求，但此时如果$f[i,j-v_i]$中max函数 第s+1项 为最大，就无法判断$f[i,j]$&#x3D;&#x3D;后s项&#x3D;&#x3D;最大值为哪一项了。</p><p><strong>所以多重背包并不适用完全背包的优化方法</strong></p></blockquote></li><li><p><strong>多重背包可以转化成01背包问题</strong></p><blockquote><p><strong>利用十进制数转化为二进制数</strong></p><blockquote><p>1,2,4,8 可以表示出0<del>15之间的任何数字。<br>对于0</del>200 1，2，4，8，…，64 可以表示 0<del>127 需要额外一个常数c&#x3D;73。<br>那么就可以表示73</del>200，这两部分重叠可以（且一定可以）覆盖0~200所有数字</p></blockquote><p>我们把第$i$种物品可选上限 $s_i$ 分成若干组，第一组1个，第二组2个，第三组4个…<br><strong>选几个可以转化为这些组每一个选或不选的问题</strong>，即01背包<br>![[Pasted image 20230216154245.png|500]]<strong>再利用01背包的空间优化，转化为一维数组进行处理</strong></p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;<span class="comment">//组数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,s;<span class="comment">//物品占容量 物品价值 物品上限</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;s);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行 “打包” 转换：二进制优化，转换成01背包</span></span><br><span class="line">        <span class="type">int</span> k=<span class="number">1</span>;<span class="comment">//每次把k个打包在一起</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt; s)</span><br><span class="line">        &#123;</span><br><span class="line">            v[cnt]=k*a,w[cnt]=k*b;<span class="comment">//打包成一个的 体积、价值</span></span><br><span class="line">            s-=k;<span class="comment">// 剩余可选上限</span></span><br><span class="line">            k*=<span class="number">2</span>;</span><br><span class="line">            cnt++;<span class="comment">//组数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)<span class="comment">//s_0 夹在2^n 和 2^(n+1)之间 直接处理剩余</span></span><br><span class="line">        &#123;</span><br><span class="line">        v[cnt]=s*a,w[cnt]=s*b;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用01背包中的空间优化模板求解。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)</span><br><span class="line">                dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性DP（2）</title>
      <link href="/2023/03/22/5.6-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2023/03/22/5.6-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230217220147.png|650]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>题目中组成递增子序列的元素可以不连续<br><strong>子序列的下一位填什么只和当前子序列的最后一位有关系。</strong><br><strong>只需要对具有相同最后一位的子序列中最长的子序列去进行后续的操作。</strong></p></blockquote><blockquote><p>一个最长子序列中包含很多子问题，因此它满足<strong>重叠子问题</strong>。<br>其次，我们每次都是让子序列中最长的去继续枚举，因此，它符合<strong>最优子结构</strong>的性质。<br>后续的选择，不会影响子问题的结果，因此，它也符合<strong>无后效性</strong>的性质。</p></blockquote><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong></p><blockquote><p>$f(i)$表示的是以$i$为结尾的子序列中的<strong>最长子序列的长度。</strong></p></blockquote><p><strong>状态转移</strong></p><blockquote><p>以当前数字$i$左侧的数字结尾的最长子序列就是$f(i)$的子问题。<br>由于子序列要求单调递增，**所以如果子序列中的最后一个数小于$i$，那么就能够选$i$**，此时这个序列的长度也加上了1。<br>然后在这些序列中取出一个最大值，我们就能找到以$i$为结尾的子序列的最大值。<br>![[Pasted image 20230217225420.png|300]]</p></blockquote><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><blockquote><p>循环很简单，就是从左遍历序列即可。</p></blockquote><blockquote><p><strong>注意</strong>：最终得到的是不同数字结尾的子序列最大值。但是题目中并没说以哪个数字为结尾，题目只需要一个最大值，因此，<strong>需要再在这些以不同数字结尾的子序列的最大值中取出一个最大值。</strong></p></blockquote><h2 id="代码-O-n-2"><a href="#代码-O-n-2" class="headerlink" title="代码 $O(n^2)$"></a>代码 $O(n^2)$</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> dp[N],a[N];<span class="comment">//i结尾的子序列长度最大值</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//从左遍历i为结尾的子序列。</span></span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;<span class="comment">//只有一个元素a[i]的时候，子序列的长度为1，设置为默认值。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)<span class="comment">//状态转移方程。</span></span><br><span class="line">        &#123;<span class="comment">//前面的数是否能和i构成子序列</span></span><br><span class="line">           <span class="keyword">if</span>(a[j]&lt;a[i]) dp[i]=max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//此事dp[i]中存储着所有i结尾的最大上升子序列</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//再次循环，挑出最大值。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = max(res, dp[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_72060925/article/details/128429202?spm=1001.2014.3001.5502">最长上升子序列优化（贪心+二分）</a> </p><h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><p>![[Pasted image 20230315180702.png|650]]</p><ul><li>朴素思路为<blockquote><p>枚举主序列所有元素$a[i]$<br>枚举$a[i]$ 之前所有的元素<br>    &gt;如果该元素比$a[i]$小 那么以该元素为结尾的子序列长度+1更新为$a[i]$结尾子序列长度</p></blockquote></li></ul><blockquote><p>其中枚举$a[i]$前面的元素时，对于以它们结尾的子序列来说，如果长度相同，优先选择结尾元素比较小的序列为优（上升空间更大）<br>该循环可以用一个二分查找</p></blockquote><p>综上，时间复杂度为$O(nlogn)$ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = max(len, r + <span class="number">1</span>);</span><br><span class="line">        q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性DP（4）</title>
      <link href="/2023/03/22/5.8-%E5%8C%BA%E9%97%B4DP%E2%80%94%E2%80%94%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/"/>
      <url>/2023/03/22/5.8-%E5%8C%BA%E9%97%B4DP%E2%80%94%E2%80%94%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230218143716.png|550]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>经典的DP问题。<br>之前的dp问题都是用$i−1$的规模的子问题来求解当前的问题。<br>其实，类似于贪心，不断地做对当下最好的选择<br>比如之前的背包问题、子序列问题，都是看的最后一个元素，只做出当下最好的选择，而体现出做最好选择的部分就是通过比较选出最大值最小值的代码。</p></blockquote><blockquote><p>但是这道题不一样，这道题将带给我们新的理解。<br>如果说之前的问题是贪心+DP，那么这个问题就是<strong>分治+贪心+DP</strong>。<br>其中DP决定了我们这道题的框架，而前面的算法决定了我们书写状态转移方程的依据</p></blockquote><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong></p><blockquote><p>$f(i,j)$ 表示合并第$i$堆到第$j$堆石子所需要的最小代价，区间$[i,j]$</p></blockquote><p><strong>状态转移</strong></p><blockquote><p>从结果要合并成一整堆来看，最后一步由两个分堆合并成一个。<br>分治的思想：（黑线表示合并两大堆石子的最优选择。）![[Pasted image 20230219115303.png|300]]<br>同样的，过程中任意某一堆$[i,j]$区间的d堆石子，分法有：(1,d-1) ; (2,d-2) ; (3,d-3) ; …;不合并<br>合并前，设左堆$[i,k]$,右堆$[k+1,j]$ ，则$[i,j]$区间的最小代价为：$$f(i,j) &#x3D; min(f(i,k)+f(k+1,j)+S[i,j]\ \ ,\ \  f(i,j))$$<em>$S[i][j]$表示两堆石子的总质量，即$[i,j]$所有石子重量，可以用</em><strong>前缀和</strong><em>表示$s[i]-s[j]$</em><br>$k$表示所有可能合并两堆石子的位置，上述k循环$i\sim j-1$即可得到该区间最小代价</p></blockquote><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><p><strong>循环</strong></p><blockquote><p>从最小的子问题开始，合并两堆未合并过的石子，区间长度是2。要枚举出所有可能合并的情况<br>外循环$i$负责区间的长度，内循环负责所有区间长度为$i$的情况，并计算出代价。</p></blockquote><p><strong>初始化</strong></p><blockquote><p> f 数组是全局变量，因此就都初始化为0，之前的问题由于是求最大值所以无需修改<br>要求最小的子问题，需要初始化成最大。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];<span class="comment">//[i,j]区间内最小合并代价</span></span><br><span class="line"><span class="type">int</span> s[N];<span class="comment">//前缀和</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        s[i]=x+s[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)<span class="comment">//区间长度len从小到大开始枚举</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;i++)<span class="comment">//枚举所有长度为len的区间的合并情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i,r=i+len<span class="number">-1</span>;</span><br><span class="line">            f[l][r]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)<span class="comment">//长度为i的某个区间内的最小合并代价</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[l][r]=min(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性DP（3）</title>
      <link href="/2023/03/22/5.7-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/03/22/5.7-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230218132138.png|550]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最终答案为3 即abd</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong></p><blockquote><p>涉及到了2个字符串，$f(i,j$)：从左向右，以第$i$个字母结尾的字符串1和以第j个字母结尾的字符串2之间最长的公共子序列的<strong>长度</strong></p></blockquote><p><strong>状态转移</strong><br>从左到右依次从两个字符串中选取两个字符$a[i]$ $b[j]$<br>    <strong>$f[i][j]$更新为</strong></p><blockquote><ol start="0"><li><p>$a[i],b[j]$ 都不选：$f[i-1][j-1]$  <em>&#x2F;&#x2F;$a[i],b[j]$都不在公共子序列中</em> </p></li><li><p>$a[i],b[j]$ 都选：$f[i-1][j-1]+1$ <em>&#x2F;&#x2F; 此时显然有$a[i]&#x3D;b[j]$的前提</em></p></li><li><p>选$a[i]$，不选$b[j]$ ：表示$a[i]$一定在子序列中，<em>但$f[i][j-1]$并不能保证$a[i]$在子序列中</em></p></li><li><p>不选$a[i]$，选$b[j]$ ：表示$b[i]$一定在子序列中，<em>但$f[i-1][j]$并不能保证$b[i]$在子序列中</em></p></li></ol><p>显然 $f[i][j-1]$ 和 $f[i-1][j]$ 情况实际上包括了00 01 10情况的子序列</p></blockquote><p><strong>由于不涉及到<em>数量</em>，即便有重复的情况也没有关系</strong></p><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j]=max(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]); </span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j]) f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性DP</title>
      <link href="/2023/03/22/5.5-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/03/22/5.5-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230217204712.png|600]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题有两种思路，可以自顶向下，而下面介绍自底向上</p><blockquote><p>这道题的情况太多了，太复杂了。而这种情况下，我们往往需要缩小问题的规模<br>![[Pasted image 20230217205246.png|500]]![[Pasted image 20230217205750.png|500]]<br>这个问题具备<strong>重叠子问题</strong>的性质。<br>同时在我们每次选择过后，问题的规模都会减小，但是我们依旧需要做出最优选择，此时说明这个问题具备<strong>最优子结构</strong>。<br>另外，我们解决大规模问题的时候，我们的小问题的最优解是没有发生变化的。而这种性质称作<strong>无后效性</strong>。<br>当一道题的问题满足上述三个性质的时候，我们通常可以使用<strong>动态规划</strong>的方式去解决。</p></blockquote><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong></p><blockquote><p>$f(i,j)$指的是，坐标为$(i,j)$的点向下走到底的时候，所能够经过路线的点的和的最大值。</p></blockquote><p>![[Pasted image 20230217215211.png|200]]</p><p><strong>状态转移</strong></p><blockquote><p>![[Pasted image 20230217214824.png|450]]</p></blockquote><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><blockquote><p><strong>相同规模的问题在同一行</strong>，<strong>最外层循坏是行数，第二层循环是列数</strong><br>一定是先从小规模的问题开始枚举，而最小规模的问题对应的是最大的下标。<strong>因此，我们只需要将第一层逆置过来即可，第二层是否逆置无所谓。</strong></p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N],a[N][N]; <span class="comment">// 各个坐标的值</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=max(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数位统计DP</title>
      <link href="/2023/03/22/5.9-%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/"/>
      <url>/2023/03/22/5.9-%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230226135601.png|650]]<br>![[Pasted image 20230226135622.png|650]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>求区间$[a,b]$中x出现的次数，利用<strong>前缀和</strong>思想，求1<del>a-1和1</del>b区间x出现的次数做差。<br>因此只需要一个count(n,x)函数求出1~n中x的次数即可。</p><blockquote><p>e.g. count(n , 1)  假定n&#x3D;7<br>    分别求出1在每一位上出现的次数<br>    设n的表示为 $n&#x3D;abcdefg$ , 比如1<del>n中表示的第四位形式为 xxx1yyy<br>    要使：<em>1 &lt;&#x3D; xxx1yyy &lt;&#x3D; abcdefg</em><br>    1) xxx &#x3D; 000</del>abc-1 , yyy &#x3D; 000<del>999 , 共$abc*1000$种选法<br>    2) xxx&#x3D; abc, yyy：<br>        <del>2.1) d &lt; 1 : 要使得 abc1yyy &lt; abc0efg 共0种可选</del><br>        2.2) d &#x3D; 1 : yyy &#x3D; 000</del>efg1 共$efg+1$种选法<br>        2.3) d &gt; 1 : yyy &#x3D; 000<del>999 共$1000$种<br>    3) xxx &gt; abc 显然不可能<br><strong>注意：</strong><br><em>（讨论第一位时，1yyyyyy， 类型1 不存在）</em><br>*对于类型1中，如果求0的出现次数，则高位xxx的范围是001</del>abc-1*</p></blockquote><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><blockquote><p>枚举总共10个数字</p><blockquote><p>算2个区间做差</p><blockquote><p>本题范围内每一位共8位</p><blockquote><p>分类讨论，最多每一位都讨论10遍</p></blockquote></blockquote></blockquote></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">001~abc-1, 999</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">    1. num[i] &lt; x, 0</span></span><br><span class="line"><span class="comment">    2. num[i] == x, 0~efg</span></span><br><span class="line"><span class="comment">    3. num[i] &gt; x, 0~999</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; num, <span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//l~r位映射到数字上用于比较</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &gt;= r; i -- ) res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">power10</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//给予相应的位权 10的i次方</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x -- ) res *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span><span class="comment">// 求出1~n中x出现的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">    <span class="keyword">while</span> (n)<span class="comment">//按位放入num</span></span><br><span class="line">    &#123;</span><br><span class="line">        num.push_back(n % <span class="number">10</span>); <span class="comment">//num&#123;ge,shi,bai,qian,...&#125;</span></span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = num.size();<span class="comment">// 位数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span> - !x; i &gt;= <span class="number">0</span>; i -- )<span class="comment">//如果x=0，当前位i从n-2开始循环</span></span><br><span class="line">    &#123;<span class="comment">// 分类讨论</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>)<span class="comment">//类型1只对非最高位时，方案存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            res += get(num, n - <span class="number">1</span>, i + <span class="number">1</span>) * power10(i);</span><br><span class="line">            <span class="keyword">if</span> (!x) res -= power10(i);<span class="comment">//讨论0个数时,高位范围从001~abc-1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num[i] == x) res += get(num, i - <span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;<span class="comment">//类型2.2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[i] &gt; x) res += power10(i);<span class="comment">//类型2.3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b , a || b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i ++ )<span class="comment">//类前缀和处理法</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; count(b, i) - count(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——第一章</title>
      <link href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h4 id="重要内容"><a href="#重要内容" class="headerlink" title="重要内容"></a>重要内容</h4><blockquote><p>互联网边缘部分和核心部分的作用，以及分组交换的概念<br>计算机网络的性能指标<br>计算机网络的分层次的体系结构的概念，协议和服务的概念，</p></blockquote><h3 id="计算机网络的一些相关知识"><a href="#计算机网络的一些相关知识" class="headerlink" title="计算机网络的一些相关知识"></a>计算机网络的一些相关知识</h3><blockquote><p><strong>三网</strong>——电信网络，有线电视网络，计算机网络<br>三网融合——将三种网络的功能融合在一起<br>计算机网络：也是一种通信基础设施，与其他两种网络不同的是计算机网络的端设备是功能强大的计算机，两个重要的功能：<strong>连通和共享</strong></p></blockquote><h3 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h3><blockquote><p><strong>互联网（因特网）：</strong> 起源于美国的因特网现在是世界上最大的国际性计算机网络<br><strong>计算机网络</strong>：由若干节点和连接这些节点的链路组成（节点可以是计算机，集线器，交换机，路由器等）<br><strong>互连网</strong>：网络和网络之间通过路由器连接起来——即网络的网络</p></blockquote><blockquote><p>因此，网络把许多计算机连接在一起，互连网将许多网络连接在一起，互联网则是特指专用名词</p></blockquote><p>互联网发展的三个阶段——</p><blockquote><p>第一阶段：单网络ARANET——1969年美国国防部建立的第一个分组交换网<br>第二阶段：三级结构的因特网——主干网，地区网，校园网<br>第三阶段: 多层次IPS（因特网服务提供者）结构的因特网</p></blockquote><p>ISP(互联网服务提供者)</p><blockquote><p>ISP可以申请到IP地址，拥有通信线路和路由器等连网设备<br>主干ISP、地区ISP、本地ISP<br>![[Pasted image 20230307214211.png|450]]</p></blockquote><p>因特网交换点IXP——（更快的转发分组，更有效地利用网络资源）允许两个网络直接相连并对等交换分组，不需要其他网络来转发分组，IXP常采用工作在数据链路层的网络交换机，这些网络交换机都用局域网互连起来（典型的IXP由一个或多个网络交换机组成，）</p><p><strong>因特网的标准化工作</strong></p><blockquote><p>所有的互联网标准都是以RFC的形式在互联网上发表的<br>ISOC——互联网协会<br>IAB——互联网体系结构委员会：负责协议开发<br>IETF——互联网工程部<br>IRTF——互联网研究部</p></blockquote><p>互联网标准形式：RFC（请求评论）<br>制定阶段：互联网草案 ——&gt; 建议标准（此时开始就是RFC了）——&gt; 互联网标准</p><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><blockquote><p><strong>边缘部分</strong>：连接在互联网上的<em>主机</em>组成，用户直接使用，通信共享。<br><strong>核心部分</strong>：由大量<em>网络</em>和连接这些网络的<em>路由器</em>组成，为边缘部分提供服务</p></blockquote><blockquote><p>边缘部分：<strong>端系统</strong>（主机）之间的通信是主机的<em>进程之间</em>——计算机之间通信。<br>端系统通信方式：<strong>客户&#x2F;服务器方式（CS方式</strong>）和 <strong>对等方式（P2P方式）</strong></p></blockquote><blockquote><p>核心部分：向网络边缘部分的主机提供连通性服务，其核心部件是实现分组交换的<strong>路由器</strong>（用来转发分组）</p></blockquote><p>两个概念：电路交换与分组交换</p><blockquote><p><strong>电路交换</strong>：建立连接——通话——释放连接（两个用户在连接期间始终占用端到端的通信资源）（连接指专用的物理通道）<em>线路传输数据快而占线多，大部分线路资源空闲，利用率低</em><br><strong>分组交换</strong>：存储转发，将报文（要发送的整块数据）划分为几个分组（<em>可以减少时延</em>），利用相关控制信息进行分装为数据单元 ，然后进行转发。<br>一个组的<strong>首部</strong>（包头）：存储目的地址和源地址。使得单个组可以独立自由地选择路线。</p></blockquote><blockquote><p><strong>总结：</strong> 端系统负责进行信息处理，路由器负责转发分组。</p></blockquote><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><blockquote><p><strong>1，按作用范围分</strong><br>广域网  WAN<br>城域网  MAN<br>局域网  LAN<br>个人区域网  PAN<br><strong>2，按网络的使用者</strong><br>公用网<br>专用网<br><strong>3，用来把端主机接入因特网的网络</strong><br>接入网</p></blockquote><h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><blockquote><p><strong>速率</strong>：数据率(比特率) <em>单位之间传输的比特位数</em><br>  <strong>带宽</strong>：<br>    (1) 本来指某个信号具有的频度带宽，信号（多种频率成分）占据的频率范围，单位：赫  <strong>频域</strong><br>    (2) <em>单位时间内信道能通过的最高数据率</em>，单位：比特每秒  <strong>时域</strong><br><strong>吞吐量</strong>：<em>单位时间内通过某网络（信道或者接口）的实际数据量</em><br><strong>时延:</strong> <em>数据从网络的一端传输到另一端所需要的时间</em> <strong>延迟或迟延</strong><br>    发送时延：发送端发送一个完整的数据帧所需要的时延<br>    传播时延：电磁波在信道中传播所需要的时间<br>    处理时延：主机或路由器处理数据分组时花费的时间<br>    排队时延：在路由器中等待分组时间<br><strong>时延带宽积</strong>——以比特为单位的链路长度：时延与带宽的乘积<br><strong>往返时间RTT</strong>：双方交互一次所需要的时间。<br><strong>利用率</strong>：包括信道利用率和网络利用率，<strong>利用率过高时延也会增加</strong><br>其他非性能特征</p></blockquote><h3 id="计算机网络的体系结构——分层次的体系结构"><a href="#计算机网络的体系结构——分层次的体系结构" class="headerlink" title="计算机网络的体系结构——分层次的体系结构"></a>计算机网络的体系结构——分层次的体系结构</h3><p><strong>SNA系统网络体系结构</strong><br><strong>OSI标准</strong>——由国际标准化组织制定的网络标准，但在实际应用中被TCP&#x2F;IP协议替代<br><strong>TCP&#x2F;IP协议</strong><br><strong>协议与划分层次——</strong></p><blockquote><p>网络协议：（明确规定交换数据的格式和有关同步问题）为进行网络中的数据交换而采取建立的规则，标准或约定<br><strong>三要素：语法   语义   同步</strong></p></blockquote><p><strong>具有五层协议的体系结构</strong>（结合OSI的七层协议体系结构和TCP&#x2F;IP的四层结构）</p><blockquote><p>应用层——通过应用进程间的交互来完成特定网络应用<br>运输层——向两个主机进程之间的通信提供通用的数据传输服务具有<strong>复用</strong>和<strong>分用</strong>的功能<br>····················（两种协议——<strong>传输控制协议TCP</strong>和<strong>用户数据协议UDP</strong>）<br>网络层——分装成数据包——IP数据报使用IP协议<br>数据链路层——分装成帧<br>物理层——考虑的是比特流的传输问题，屏蔽传输媒体的差异性</p></blockquote><p><strong>相关概念：</strong></p><blockquote><p>协议数据单元PDU：OSI参考模型为对等层次之间传送的数据单位的命名<br>实体：任何可以接受或者发送信息的软件进程或者硬件<br>协议：控制两个对等实体进行通信的规则的集合<br>在协议控制下，下层向上层提供服务，所以协议是水平的，服务是垂直的</p></blockquote><p><strong>TCP&#x2F;IP协议族示意图</strong><br>![[Pasted image 20230222102032.png|600]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——第二章</title>
      <link href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><h4 id="重要内容"><a href="#重要内容" class="headerlink" title="重要内容"></a>重要内容</h4><blockquote><p>物理层的任务<br>几种常用的信道复用技术<br>几种常用的宽带接入技术，主要是ADSL，FTTx</p></blockquote><h3 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><p>物理层的作用是<strong>屏蔽掉传输媒体和通信手段（即物理设备）的差异，让上层的链路层不必考虑物理层差异。</strong> 物理层协议——<strong>规程</strong><br>物理层的主要任务</p><blockquote><p><strong>确定与传输媒体的接口有关的一些特性</strong><br>1）机械特性：指明接口的尺寸形状等物理适配。<br>2）电气特性：指明接口电缆各线的电压范围<br>3）功能特性：指明线上某一电平的电压意义<br>4）过程特性：指明事件出现顺序<br>完成数据在<strong>计算机内部（并行传输）</strong> 与 <strong>通信线路上（串行传输）</strong> 之间的串并传输方式的转换</p></blockquote><h3 id="数据通信的基本知识"><a href="#数据通信的基本知识" class="headerlink" title="数据通信的基本知识"></a>数据通信的基本知识</h3><p><strong>1）数据通信系统的模型</strong><br><strong>源系统——传输系统——目的系统</strong><br>![[Pasted image 20230315005705.png|500]]</p><blockquote><ol><li><strong>源系统（源点，发送器）</strong><br>源点：源点设备要传输的数据<br>发送器：源点比特流的的<strong>调制器</strong>，转化为信号</li><li><strong>传输系统（传输线或者网络）</strong></li><li><strong>目的系统（接收器，终点）</strong><br>接收器：接受传输系统的信号并转化为目的设备处理的信息的<strong>调制器</strong><br>终点：获取接收器的数字比特流</li></ol></blockquote><p>常用术语：  </p><blockquote><p>消息：传送的信息<br>数据：消息的实体，即用特定方式表示的信息<br>信号：数据的电气或者电磁表现  可以分为两类：<strong>模拟信号</strong>和<strong>数字信号</strong><br><strong>码元</strong>：使用时域的波形表示数字信号（离散信号）时，代表不同离散数值的基本波形。</p></blockquote><p><strong>2）信道的基本概念</strong><br><strong>信道</strong>：向某一个方向传送信息的媒体。<br>三种形式：</p><blockquote><p><strong>单向信道</strong>：一方发送，一方接收<br><strong>双向交替信道</strong>：双方都可发送消息，但不能同时进行  <strong>单工</strong><br><strong>双向同时信道</strong>：双方可同时发送信息  </p></blockquote><p><strong>基带信号</strong>（基本频带信号）：<strong>来自信源的信号</strong>。包含较多<em>低频分量</em>甚至<em>直流分量</em>（许多信道不能传输）<br><strong>调制</strong>：<em>将来自源信号的低频甚至直流信号进行变换</em>，使得这种低频直流信号可以便于在信道内传输  </p><blockquote><p>两种调制方法：</p></blockquote><blockquote><p><strong>基带调制</strong>： 把数字信号转换为另一种形式的数字信号，即<em>仅对信号的波形进行变换</em>，可称之为<strong>编码</strong>调制<br><img src="https://img-blog.csdn.net/20180918172905582?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDY4MTMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="|500">不归零制：<strong>电平正负</strong>分别表示1、0<br>归零制：<strong>正负脉冲</strong>分别表示1、0<br>曼彻斯特编码：周期<strong>中心跳动方向</strong>上和下分别为0、1<br>差分曼彻斯特编码：每一位中心都有跳变。<strong>位开始边界有无跳变</strong>分别表示0、1</p></blockquote><blockquote><p><strong>带通调制</strong>：使用<strong>载波</strong>进行调制，<em>将基带信号的频率般到高频段，并将之转换为模拟信号</em>，此时信号也称<strong>带通信号</strong>。<br><img src="https://img-blog.csdn.net/20180918172947184?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDY4MTMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="|500"><br>调幅：<strong>有无载波</strong>分对应0、1<br>调频：<strong>不同频率</strong>区分0、1<br>调相：<strong>初始相位</strong>0和180对应0、1<br><strong>正交振幅调制</strong></p></blockquote><p><strong>3）信道极限容量</strong><br>一定的失真不影响数字通信。但要避免失真严重<br>（码元速率过高、信号传输距离过远、噪声干扰大、传输媒体质量低）</p><ul><li>码元在信道上的传输速率</li></ul><ol><li>信道所能通过的频率范围<blockquote><p><strong>码间串扰</strong>：信道传输的频率范围有限，导致高频分量衰减，码元拖影导致码元之间界限模糊。<br><em>奈氏准则</em>：每赫带宽的理想低通信道的最高码元传输速率V是每秒2个码元.$$V&#x3D;2W$$</p></blockquote></li><li>信噪比<blockquote><p>噪声对信号的影响是相对的，信号越强，影响越小，因此考虑信噪比。<br>$信噪比(dB) &#x3D; 10 log_{10}(S&#x2F;N)(dB)$<br><em>香农公式</em>：信道<strong>极限</strong>传输速率C,信道带宽W,信噪比S&#x2F;N$$C&#x3D;Wlog_{2}(1+S&#x2F;N)(bit&#x2F;s)$$ <strong>带宽和信噪比越高，信息传输速率上限越高</strong></p></blockquote></li></ol><p>增加每个码元携带的信息量可以提高信息传输速率，但一个码元表示比特越多，抗干扰要求越高。</p><h3 id="物理层下面的传输媒体："><a href="#物理层下面的传输媒体：" class="headerlink" title="物理层下面的传输媒体："></a>物理层下面的传输媒体：</h3><blockquote><p>引导性传输媒体：双绞线，同轴电缆，光缆，<br>非引导型传输媒体：即无线传输</p></blockquote><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><p><strong>复用</strong>：发送端使用一个复用器，接收端使用分用器，使用共享信道。<br>![[Pasted image 20230308112649.png|350]]<br><strong>频分复用FDM</strong></p><blockquote><p>用户在同样的时间内<em>占用不同的频率带宽</em>而复用同一个信道   <br>![[Pasted image 20230315095021.png|400]]</p></blockquote><p><strong>时分复用TDM</strong></p><blockquote><p>将时间划分为相同的时分复用帧TDM，<em>在不同的时间占用相同的频带宽度</em>，利于数字信号。由于时分复用会在用户间不断切换，所以不使用的用户也会占用，使用的只占用一部分。<strong>利用率不高</strong><br>![[Pasted image 20230315095047.png|400]]</p></blockquote><p><strong>统计时分复用STDM</strong> </p><blockquote><p>改进的时分复用，按需动态分配时隙，而不是固定分配时隙 （每个STMD帧的时隙数小于连接在<em>集中器</em>上的用户数，使得<strong>每次传送的STDM帧中的分组都是满的</strong>。又称<em>异步时分复用</em>。由于信息顺序打乱不可预知，<strong>每个STDM前端一部分存放用户地址</strong>，用来判别对应的用户。<br>![[Pasted image 20230308120657.png|350]]</p></blockquote><p><strong>波分复用WDM</strong></p><blockquote><p>光的频分复用，利用在光线技术通信中；光频率高，所以采用波长区分。<br>复用器:<strong>合波器</strong>。分用器：<strong>分波器</strong>。<br><strong>密集波分复用</strong>，复用器：<strong>光复用器</strong>，分用器：<strong>光分用器</strong><br>![[Pasted image 20230315101822.png|400]]</p></blockquote><p><strong>码分复用CDM</strong></p><blockquote><p>每个用户在相同的时间使用相同的频带进行通信，但各用户使用经过挑选的<strong>不同码型</strong>，从而使得个用户之间可以进行独立的通信.<br><strong>码片</strong>：1bit的时间进一步划分。占用的频率带宽提高，<strong>扩频</strong>。<br><strong>码片序列</strong>：序列自身代表1，反码代表0；不同站点间码片序列<strong>规格化内积</strong>为0，同序列或者反码<strong>规格化内积</strong>分别为1和-1；<br>![[Pasted image 20230315101845.png|400]]</p></blockquote><h3 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h3><h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><p>宽带：将用户连接到某个ISP以获取上网所需的IP地址。<br><strong>有线宽带接入</strong>——ADSL技术和FTTX技术<br><strong>无线宽带接入</strong><br>非对称数字用户线ADSL：对现有模拟电话的用户线改造<br>非对称数字用户线ASDL技术是用数字技术对现有的模拟电话用户线进行改造，使其能够承载宽带业务的一种技术；<br>光纤同轴混合网HFC在有线电视网的基础上开发的<br>光纤到户技术FTTH</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/19/hello-world/"/>
      <url>/2023/03/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>视频</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
