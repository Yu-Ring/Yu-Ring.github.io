<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/08/18/$_attachments/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/08/18/$_attachments/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>![[IMG_0258(20230108-230422).jpg]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/18/$_attachments/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/08/18/$_attachments/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>![[IMG_0259(20230108-230438).jpg]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/18/$_attachments/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/08/18/$_attachments/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>![[2A87D43A9297426A571D301FAC0C0514.png]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/08/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="项目构成"><a href="#项目构成" class="headerlink" title="项目构成"></a>项目构成</h2><ul><li><code>pages</code> 程序的各种页面</li><li><code>utils</code> 工具性质模块</li><li><code>app.js</code> 小程序项目入口文件</li><li><code>app.json</code> 全局配置 <em>静态</em></li><li><code>app.wxss</code> 全局样式 <em>类似于类、预设</em></li><li><code>project.config.json</code> 项目配置文件</li><li><code>sitemap.json</code> 配置小程序及其页面是否允许被微信索引</li></ul><h4 id="pages构成"><a href="#pages构成" class="headerlink" title="pages构成"></a>pages构成</h4><ul><li><code>.js</code> 页面脚本。页面数据，事件处理</li><li><code>.json</code> 配置文件。窗口外观表现</li><li><code>.wxml</code> 页面模板结构</li><li><code>.wxss</code> 页面样式<br>![[Pasted image 20230509220235.png#pic]]<br><strong>.json</strong></li><li>app.json：所有的页面路径 窗口外观 界面表现 底部tab<blockquote><p>pages 管理各个页面的路径 <em>每次新建pages类型文件夹会自动添加</em> <em>第一个为默认页面</em><br>window 所有页面的背景色文字颜色<br>style 使用组件的版本<br>![[Pasted image 20230509212341.png|300]]</p></blockquote></li><li>project.config.json：<blockquote><p>本地设置。对小程序开发工具的个性化配置</p></blockquote></li><li>sitemap.json<blockquote><p>页面可否被微信索引，<em>可在project.config.json的checkSiteMap修改是否有索引提示</em></p></blockquote></li><li>.json<blockquote><p>单个页面的配置文件，相较于全局的app.json。<em>属性冲突情况下，局部页面属性优先更高。</em></p></blockquote></li></ul><p><strong>.wxml</strong><br>格式：<code>&lt;标签 属性&gt; 内容 &lt;/标签&gt;</code></p><blockquote><p><strong>标签</strong>:  view text image navigator等 <code>&lt;text&gt; ... &lt;/text&gt;</code><br><strong>属性</strong>:  url &#x3D; “…” color &#x3D; “…”等<code>&lt;navigator url = &quot; &quot;&gt; ... &lt;/navigator&gt;</code><br><strong>数据绑定</strong> <br><strong>列表渲染</strong>：wx:for &#x3D; ““</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;array&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>条件渲染</strong>:  wx:if &#x3D; ““</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;</span>&gt;</span> 2 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span> 3 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>.wxss</strong></p><ul><li>新增rpx尺寸单位（随不同设备自动调整，无需css的手动像素单位换算rem）</li><li>仅支持部分CSS选择器<blockquote><p><code>.class 和 #id</code>、<code>element</code> 、<code>并集选择器</code>、<code>后代选择器</code>、<code>::after ::before伪选择器</code></p></blockquote></li></ul><p><strong>.js</strong></p><ul><li>app.js 程序入口文件 <code>app()</code>函数启动整个小程序</li><li>页面.js 页面入口文件 <code>page()</code>函数创建并运行页面</li><li>.js 功能模块 封装公共 <em>函数和属性</em> 供页面使用</li></ul><h2 id="宿主环境"><a href="#宿主环境" class="headerlink" title="宿主环境"></a>宿主环境</h2><p><strong>宿主环境</strong>：安卓app宿主环境是安卓，苹果app宿主环境是ios 小程序宿主环境是微信<br><strong>小程序宿主环境提供的内容：</strong></p><ul><li><p><strong>通信模型</strong></p><blockquote><p>渲染层：wxml wxss<br>逻辑层：js脚本<br><strong>渲染层——逻辑层通信</strong>：<br><strong>逻辑层——第三方服务器通信</strong>：<br>![[Pasted image 20230509223123.png|400]]</p></blockquote></li><li><p><strong>运行机制</strong></p><blockquote><p><strong>启动</strong>：代码包下载到本地–解析app.json–执行app.js–渲染首页–启动完成<br><strong>页面渲染</strong>：加载.json–加载.wxml .wxss</p></blockquote></li><li><p><strong>组件</strong></p><blockquote><p>视图容器、表单组件等</p></blockquote></li><li><p><strong>API</strong></p><blockquote><p><strong>事件监听类API</strong> on开头，监听事件触发<br><strong>同步API</strong> Sync结尾 可通过函数返回值直接获取 如果直接出错会报异常<br><strong>异步API</strong> request发送网络数据请求，回调函数接收数据</p></blockquote></li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li><input checked="" disabled="" type="checkbox"> view</li><li><input checked="" disabled="" type="checkbox"> scroll-view<blockquote><p><code>nth-child()</code>选择器wxss<br><code>scroll-y</code>滚动方向</p></blockquote></li><li><input checked="" disabled="" type="checkbox"> swiper<blockquote><p><strong>indicator-dots</strong><br><code>indicator-color=&quot;white&quot;</code> 未激活颜色<br><code>indicator-active color=&quot;red&quot;</code>激活颜色<br><code>autoplay=&quot;true&quot;</code> <code>interval=&quot;3000&quot;</code> 自动播放 播放间隔<br><code>circular=&quot;true&quot;</code> 循环</p></blockquote></li><li><input checked="" disabled="" type="checkbox"> text<blockquote><p><code>user-select</code> 是否可选中</p></blockquote></li><li><input checked="" disabled="" type="checkbox"> rich-text<blockquote><p><code>nodes=&quot;&lt;h1 style = &#39;color:red;&#39;&gt;&lt;h1&gt;&quot;</code>属性节点把HTML字符串渲染为对应的UI结构</p></blockquote></li><li><input checked="" disabled="" type="checkbox"> button<blockquote><p><code>size=&quot;mini&quot;</code> <code>plain = &quot;true&quot;</code> 镂空按钮 <em>app.json的style:v2</em></p></blockquote></li><li><input checked="" disabled="" type="checkbox"> image<blockquote><p><strong>mode</strong>值 <em>填充方式</em></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span> = <span class="string">&quot;/images/Mimikyu.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span> = <span class="string">&quot;/images/Mimikyu.jpg&quot;</span> <span class="attr">mode</span> = <span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span> = <span class="string">&quot;/images/Mimikyu.jpg&quot;</span> <span class="attr">mode</span> = <span class="string">&quot;scaleToFill&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span> = <span class="string">&quot;/images/Mimikyu.jpg&quot;</span> <span class="attr">mode</span> = <span class="string">&quot;widthFix&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="WXML语法"><a href="#WXML语法" class="headerlink" title="WXML语法"></a>WXML语法</h2><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><blockquote><p>.js文件中定义：data：<code>&#123; 数据名1：数据 ，数据名2：数据 &#125;</code><br>.wxml中使用 :  Mustache语法 <code>&#123;&#123;数据名&#125;&#125;</code> <code>&#123;&#123;运算&#125;&#125;</code></p></blockquote><ul><li><p>动态绑定内容</p></li><li><p>动态绑定属性</p></li><li><p>Mustache中运算</p></li></ul><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><blockquote><p>用户在渲染层产生的行为，反馈到逻辑层进行处理<br>![[Pasted image 20230513154439.png|400]]</p></blockquote><ul><li>tap <blockquote><p>触摸click触发，bindtap（bind:tap)</p></blockquote></li><li>input<blockquote><p>文本框输入事件，bindinput（bind:input）</p></blockquote></li><li>change<blockquote><p>状态改变触发，bindchange（bind:change)</p></blockquote></li></ul><p>事件对象evevt的属性</p><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>string</td><td>事件类型</td></tr><tr><td>timeStamp</td><td>Integer</td><td>page打开到触发所经过的事件ms</td></tr><tr><td>target</td><td>Object</td><td>触发事件组件的属性值集合</td></tr><tr><td>currentTarget</td><td>Object</td><td>当前组件的一些属性值集合</td></tr><tr><td>detail</td><td>Object</td><td>额外的信息</td></tr><tr><td>touches</td><td>Array</td><td>触摸事件，停留触摸点信息的数组</td></tr><tr><td>changedTouches</td><td>Array</td><td>触摸事件，当前变化的触摸点信息的数组</td></tr><tr><td><strong>target与currentTarget</strong>：target是触发事件的源头组件，currenttarget是当前事件绑定的组件</td><td></td><td></td></tr><tr><td>![[Pasted image 20230513164916.png]]</td><td></td><td></td></tr></tbody></table><ul><li>bindtap打印实例<blockquote><p><code>&lt;button type=&quot;primary&quot; bindtap = &quot;事件函数&quot;&gt;按钮&lt;/button&gt;</code></p></blockquote></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">bindtap</span> = <span class="string">&quot;btnTapHandler&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">btnTapHandler</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e) <span class="comment">// 打印参数对象到console控制台</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>![[Pasted image 20230513192709.png]]</p><ul><li><p><strong>事件处理函数中修改数据</strong><br>通过调用<code>this.setData(dataObject)</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">bindtap</span> = <span class="string">&quot;changeCount1&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">changeCount1</span>(<span class="params"></span>)&#123;<span class="comment">//前面data中已有count1，否则自动新建</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;<span class="attr">count1</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">count1</span> + <span class="number">1</span>&#125;)  <span class="comment">//给count1赋新值 </span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>![[Pasted image 20230513194630.png|400]]<br>![[Pasted image 20230513194601.png|400]]</p></li><li><p>事件传参</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">btnTap2</span>(<span class="params">e</span>)&#123;<span class="comment">//前面data中已有count1，否则自动新建</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)<span class="comment">// 在console打印e相关信息</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;<span class="attr">count1</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">count1</span> + e.<span class="property">target</span>.<span class="property">dataset</span>.<span class="property">varx</span>&#125;) </span><br><span class="line">    <span class="comment">//count1自增+2</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnTap2&quot;</span> <span class="attr">data-varx</span>=<span class="string">&quot;&#123;&#123;2&#125;&#125;&quot;</span>&gt;</span>+2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><ul><li><p><code>wx:if</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span> = <span class="string">&quot;&#123;&#123;condition === 1&#125;&#125;&quot;</span>&gt;</span>情况一渲染<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span> = <span class="string">&quot;&#123;&#123;condition === 2&#125;&#125;&quot;</span>&gt;</span>情况二渲染<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span>其他情况<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>block</code>标签包裹 控制多个组件的展示与隐藏</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;true&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>1<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>2<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>用<code>view</code>标签也可以包裹，但会该标签本身会被渲染出来，而<code>block</code>不会被渲染。<br>具体表现形式为，在调试器的“审查”箭头 指向被包裹的组件时，前者识别大的view，后者识别内部组件。</p></blockquote></li><li><p><code>hidden</code>控制元素的隐藏与显示<br>条件为<code>true</code>隐藏；条件为<code>false</code>显示</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hidden</span> = <span class="string">&quot;&#123;&#123;true&#125;&#125;&quot;</span>&gt;</span>1隐藏<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hidden</span> = <span class="string">&quot;&#123;&#123;false&#125;&#125;&quot;</span>&gt;</span>2不隐藏<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>hidden</code> 与 <code>wx:if</code> 对比：<br>前者以切换<code>display:none/block</code>的样式切换，只能识别true和false；<br>后者要动态创建和移除元素样式。<br><strong>如果频繁进行切换，使用<code>hidden</code>；如果控制比较复杂，使用<code>wx:if</code></strong></p></blockquote></li></ul><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><ul><li><p><code>wx:for</code> 循环渲染数组</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;array&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">索引为：&#123;&#123;index&#125;&#125;，当前项：&#123;&#123;item&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>wx:for-index</code> 和 <code>wx:for-item</code> 替代索引及其变量名</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;array&#125;&#125;&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;idx&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;itemName&quot;</span>&gt;</span></span><br><span class="line">索引为：&#123;&#123;idx&#125;&#125;，当前项：&#123;&#123;itemName&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>wx:key</code> 循环时通过对象数组内某个属性作为key值进行渲染</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">list</span>:[</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">itmName</span>:<span class="string">&quot;xxx&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">itmName</span>:<span class="string">&quot;yyy&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">itmName</span>:<span class="string">&quot;zzz&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>通过key值渲染</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span>&gt;</span>&#123;&#123;itmName&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="WXSS语法"><a href="#WXSS语法" class="headerlink" title="WXSS语法"></a>WXSS语法</h2><h3 id="小程序长度单位rpx"><a href="#小程序长度单位rpx" class="headerlink" title="小程序长度单位rpx"></a>小程序长度单位rpx</h3><p>所有设备的屏幕宽度上等分成750份，每份长度叫做<code>rpx</code></p><h3 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h3><blockquote><p>建立一个common文件夹，建立<code>common.css</code>，并在其中写可能用到的公共样式表<br>在各个页面的wxss中通过<code>@import &quot;/common/common.wxss&quot;;</code>后，该页面的wxml中可以使用对应class</p></blockquote><h2 id="全局与页面配置"><a href="#全局与页面配置" class="headerlink" title="全局与页面配置"></a>全局与页面配置</h2><h3 id="全局样式与局部样式"><a href="#全局样式与局部样式" class="headerlink" title="全局样式与局部样式"></a>全局样式与局部样式</h3><ul><li><code>app.wxss</code> 全局样式 影响到所有页面 优先级比局部低</li><li><code>???.wxss</code> 局部样式 只影响当前页面 优先级更高<blockquote><p>注：实际全局样式中有些指定范围更精准（也称<strong>权重</strong>更大）可以覆盖局部样式<br>比如全局样式中<code>view:nth-child(1)</code> 指定第一个使用view组件的标签 比 局部样式直接定义<code>view</code>的权重要大。</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">view&#123;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">10</span>rpx;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">10</span>rpx;</span><br><span class="line"><span class="attribute">background-color</span>:lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">view<span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="全局配置-app-json"><a href="#全局配置-app-json" class="headerlink" title="全局配置 app.json"></a>全局配置 <code>app.json</code></h3><h4 id="pages-页面路径"><a href="#pages-页面路径" class="headerlink" title="pages 页面路径"></a>pages 页面路径</h4><h4 id="window-小程序窗口外观"><a href="#window-小程序窗口外观" class="headerlink" title="window 小程序窗口外观"></a>window 小程序窗口外观</h4><p>![[Pasted image 20230703203007.png|400]]<br>控制代码：![[Pasted image 20230703204131.png]]</p><blockquote><p><strong>全局开启下拉刷新功能</strong>: 需要在window中新增<code>&quot;enablePullDownRefresh&quot;: true&quot;</code><br><strong>下拉刷新背景色</strong>：<code>&quot;backgroundColor&quot;:#十六进制颜色值</code><br><strong>下拉loading样式</strong>：<code>&quot;backgroundTextStyle&quot;: &quot;dark&quot;</code></p></blockquote><blockquote><p><strong>上拉触底</strong>：<code>&quot;onReachBottomDistance&quot;: 50</code>，默认为50</p></blockquote><h4 id="tabBar-小程序底部tabBar效果"><a href="#tabBar-小程序底部tabBar效果" class="headerlink" title="tabBar 小程序底部tabBar效果"></a>tabBar 小程序底部tabBar效果</h4><ul><li>tabBar各配置参数对应渲染效果图<br>![[Pasted image 20230704201906.png|500]]<blockquote><p>在<code>app.json</code>中与<code>window</code> 和 <code>pages</code>同级新建一个<code>tabBar</code> 。<br>增加配置项。![[Pasted image 20230704202250.png|500]]<br><code>list</code>为必选，以下为list中每个对象的配置![[Pasted image 20230704202044.png|500]]</p></blockquote></li></ul><h5 id="具体演示"><a href="#具体演示" class="headerlink" title="具体演示"></a>具体演示</h5><ul><li>代码<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;tabBar&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/index/index&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/代办买药 (1).png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/代办买药.png&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/demo/demo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;demo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/全程陪诊 (1).png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/全程陪诊.png&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/wxml_language/wxml_language&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wxml&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/代办问诊 (1).png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/代办问诊.png&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>渲染结果如下<br>![[Pasted image 20230704210519.png|300]]</li></ul><h4 id="style-是否启用新版组件效果"><a href="#style-是否启用新版组件效果" class="headerlink" title="style 是否启用新版组件效果"></a>style 是否启用新版组件效果</h4><h3 id="页面配置-json"><a href="#页面配置-json" class="headerlink" title="页面配置 ???.json"></a>页面配置 <code>???.json</code></h3><blockquote><p>页面配置优先级比全局配置高<br>![[Pasted image 20230704211653.png|500]]</p></blockquote><h4 id="具体演示-1"><a href="#具体演示-1" class="headerlink" title="具体演示"></a>具体演示</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;navigationBarTitleText&quot;</span><span class="punctuation">:</span> <span class="string">&quot;列表页面&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;backgroundColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#D4F2E7&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;navigationBarBackgroundColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#B0C4DE&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>![[Pasted image 20230704213718.png|300]]</p><h2 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h2><h4 id="配置合法域名"><a href="#配置合法域名" class="headerlink" title="配置合法域名"></a>配置合法域名</h4><blockquote><p>微信小程序 只能请求<strong>https类型接口</strong>，且必须把接口的<strong>域名添加到信任列表</strong>中![[Pasted image 20230704214033.png|300]]<br>登录小程序管理后台&gt;配置服务器域名![[Pasted image 20230705204947.png]]</p></blockquote><h4 id="发起GET请求"><a href="#发起GET请求" class="headerlink" title="发起GET请求"></a>发起GET请求</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getInfo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;https://escook.cn/api/get&#x27;</span>,</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">20</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="comment">//请求成功的数据以参数res返回，=&gt;指向处理res的回调函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)<span class="comment">//“&#123;&#125;”内处理res</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h4 id="发起POST请求"><a href="#发起POST请求" class="headerlink" title="发起POST请求"></a>发起POST请求</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">postInfo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;https://www.escook.cn/api/get&#x27;</span>,</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;ls&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">33</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h4 id="加载页面时请求"><a href="#加载页面时请求" class="headerlink" title="加载页面时请求"></a>加载页面时请求</h4><p><code>onLoad</code>函数中调用<code>this.getXXXXX</code>使得本页面的实例申请</p><h4 id="跳过reques合法域名校验"><a href="#跳过reques合法域名校验" class="headerlink" title="跳过reques合法域名校验"></a>跳过reques合法域名校验</h4><blockquote><p>对于后端未能提供https的接口，可以在小程序右上角&gt;详情&gt;本地设置&gt;勾选<code>不校验合法域名</code><br>仅能在开发和调试阶段使用，正式上线不可使用</p></blockquote><h4 id="关于回调函数"><a href="#关于回调函数" class="headerlink" title="关于回调函数"></a>关于回调函数</h4><blockquote><p>回调函数允许我们在执行某个任务时，将<strong>一个函数作为参数</strong>传递给另一个函数，<strong>在任务完成后再调用这个函数</strong>，以完成进一步的处理。<br>常用于异步编程中，当我们需要在异步操作完成后执行某些操作时，可以将这些操作封装在回调函数中，并将回调函数作为参数传递给异步函数，等异步操作完成后再执行回调函数。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;https://example.com&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">fail</span>: <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中，我们将一个对象作为参数传递给 <code>wx.request</code>，对象中包含 <code>success</code> 和 <code>fail</code> 两个回调函数。当异步操作完成后，如果成功，将调用 <code>success</code> 函数，并将结果作为参数传递给它；如果失败，将调用 <code>fail</code> 函数，并将错误信息作为参数传递给它。<br>由于网络请求是一个异步操作，在<strong>发起请求后，程序会立即执行后续的语句</strong>，而不会等待请求完成。当请求完成后，<strong>如果请求成功，将调用 <code>success</code> 回调函数</strong>，并将包含响应内容的 <code>res</code> 对象作为参数传递给它；<strong>如果请求失败，将调用 <code>fail</code> 回调函数</strong>，并将错误信息作为参数传递给它。因此，**<code>success</code> 和 <code>fail</code> 函数的执行将<em>被延迟到网络请求完成后</em>**，它们的执行顺序也与代码的书写顺序无关，这就是异步编程的体现。</p></blockquote><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="运营数据"><a href="#运营数据" class="headerlink" title="运营数据"></a>运营数据</h2><ul><li>小程序后台</li><li>小程序数据助手</li></ul><h2 id="案例实操1"><a href="#案例实操1" class="headerlink" title="案例实操1"></a>案例实操1</h2><h4 id="准备部分"><a href="#准备部分" class="headerlink" title="准备部分"></a>准备部分</h4><ul><li><p>创建小程序</p></li><li><p><code>app.json</code> 中配置需要的页面</p></li><li><p><code>app.json</code> 中修改window配置参数</p></li><li><p><code>app.json</code> 中增加tabBar</p></li><li><p>页面js设置data</p></li><li><p>页面js设置函数getXXX</p></li><li><p>页面js设置onLoad函数并用this.getXXX调用</p></li></ul><h4 id="轮播图实操"><a href="#轮播图实操" class="headerlink" title="轮播图实操"></a>轮播图实操</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>js文件下，data内定义一个轮播图列表<br><code>swiperList: []</code></li><li>js文件下，定义<code>getSwiperList()</code>获取轮播图函数<blockquote><p><code>wx.request(&#123;url:&#39;xxx&#39;,method:&#39;xxx&#39;,success:(res)=&gt;&#123;处理返回数据的回调函数&#125;&#125;)</code></p></blockquote></li><li>js文件下，<code>onLoad()</code>调用<code>getSwiperList()</code></li><li>wxml文件下，代码嵌套<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swiper</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">swiper-item</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;swiperList&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;item.image&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>![[Pasted image 20230727210842.png|600]]</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 是否显示面板指示点，指示点颜色：rgba(r,g,b,透明度 0.x一般省略0) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前显示点颜色，是否自动播放，当前滑块所在index：1 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">indicator-dots</span> = <span class="string">&quot;&#123;&#123;swiperdot&#125;&#125;&quot;</span> <span class="attr">indicator-color</span> = <span class="string">&quot;rgba(255,0,0,.3)&quot;</span> <span class="attr">indicator-active-color</span> = <span class="string">&quot;#000080&quot;</span> <span class="attr">autoplay</span> = <span class="string">&quot;true&quot;</span> <span class="attr">current</span>=<span class="string">&quot;1&quot;</span> <span class="attr">circular</span>=<span class="string">&quot;true&quot;</span> <span class="attr">next-margin</span> = <span class="string">&quot;60rpx&quot;</span>  <span class="attr">previous-margin</span>=<span class="string">&quot;60rpx&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;imageList&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;this&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">swiper-item</span> <span class="attr">style</span>=<span class="string">&quot;display: flex; justify-content: space-around;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span> = <span class="string">&quot;&#123;&#123;item&#125;&#125;&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;aspectFill&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="导航实操"><a href="#导航实操" class="headerlink" title="导航实操"></a>导航实操</h4><h5 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h5><ul><li>声明式导航 <code>navigator</code>组件<blockquote><p>导航到tabBar页面，需要制定<code>url:/开头</code>和<code>open-type:switchTab</code><br>导航到非tabBar页面，同上，但<code>open-type:navigate</code>（可省略）<br>后退导航，<code>open-type:navigateback</code>，返回步长<code>delta=返回次数</code>（可省略默认1）</p></blockquote></li><li>编程式导航 调用小程序API<code>wx.switchXXX</code><blockquote><p>导航到tabBar页面，组件通过<code>bindTap</code>事件绑定属性，触发事件函数，事件函数内写<code>wx.switchXXX(&#123;url:&#39;xxx&#39;&#125;)</code><br>导航到非tabBar页面，同上，<code>wx.navigateTo(&#123;url:&#39;xxx&#39;&#125;)</code><br>后退导航，同上，<code>wx.navigateBack(&#123;url:&#39;xxx&#39;&#125;)</code> 返回步长<code>delta=返回次数</code><br><strong>额外可选属性</strong><code>success fail complete</code>回调函数</p></blockquote></li></ul><h5 id="导航传参"><a href="#导航传参" class="headerlink" title="导航传参"></a>导航传参</h5><ul><li>声明式和编程式导航<blockquote><p><code>url</code>内，跟在路径后用<code>?</code>分割，参数键与参数值<code>=</code>相连，多个参数<code>&amp;</code>分隔</p></blockquote></li><li><code>onLoad</code>接收导航参数<blockquote><p><code>onLoad:function(options)&#123;对options对象操作&#125;</code> <em>一般会在data全局定义一个query对象，再在{}中复制options对象</em></p></blockquote></li><li>传参更改页面标题<blockquote><p>在生命周期<code>onReady</code>更改，<code>wx.setNavigationBarTitle(&#123;title:&#39;xxx&#39;&#125;)</code>,<em>title参数需要全局定义变量复制options对象</em></p></blockquote></li></ul><h4 id="上拉与下拉"><a href="#上拉与下拉" class="headerlink" title="上拉与下拉"></a>上拉与下拉</h4><h5 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h5><ul><li>全局开启<blockquote><p><code>app.json</code>的window中，令<code>&quot;enablePullDownRefresh&quot;:true</code></p></blockquote></li><li>局部开启<blockquote><p><code>???.json</code>，令<code>&quot;enablePullDownRefresh&quot;:true</code></p></blockquote></li><li>下拉刷新窗口样式<blockquote><p><code>backgroundColor</code>、<code>backgroundTextStyle</code> </p></blockquote></li><li>监听页面下拉刷新事件<blockquote><p>通过<code>onPullDownRefresh:function()&#123;this.处理事件&#125;</code></p></blockquote></li><li>事件处理完毕后主动停止下拉刷新事件<blockquote><p>下拉刷新不会主动停止，在function结尾处添加<code>wx.stopPullDownRefresh()</code>即可</p></blockquote></li></ul><h5 id="上拉触底"><a href="#上拉触底" class="headerlink" title="上拉触底"></a>上拉触底</h5><ul><li>监听页面上拉触顶事件<blockquote><p>通过<code>onReachBottom()&#123;this.处理事件&#125;</code></p></blockquote></li><li>上拉触底距离<blockquote><p>触发事件时，距离底部的距离，可在<code>???.json</code>中配置<code>onReachBottomDistance()</code>，默认50px</p></blockquote></li><li>loading提示框<blockquote><p><code>wx.hideLoading()</code> <code>wx.showLoading(&#123;显示的文字&#125;)</code></p></blockquote></li><li>节流（loading期间拒绝新的请求）<blockquote><p>data中定义<code>isloading</code>的节流阈 <code>true &amp; false</code><br>监听处理事件中 开始：<code>isloading:true</code>；complete回调函数结束： <code>isloading:false</code><br>监听触发事件中 <code>onReachBottom()&#123;&#125;</code>判断<code>isloading</code>的值</p></blockquote></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>生命周期概念</li><li>生命周期分类<blockquote><p>应用生命周期（启动-运行-销毁），页面生命周期（加载-渲染-销毁）</p></blockquote></li><li>生命周期函数<blockquote><p>概念：小程序框架内置函数，伴随生命周期，自动按次序执行。<br>作用：运行程序员在特定的生命周期的事件点，执行操作。</p></blockquote></li><li>应用生命周期函数<blockquote><p><code>app.js</code>中，有<br><code>onLaunch:function(options)&#123;&#125;</code>初始化完成时，全局只触发一次<br><code>onShow:function(options)&#123;&#125;</code>小程序启动时or从后台进入前台时<br><code>on:function(options)&#123;&#125;</code>从前台进入后台时<br>![[Pasted image 20230730003012.png|250]]<br><em>输入app第三个选项可以自动创建完整生命周期函数</em></p></blockquote></li><li>页面生命周期函数<blockquote><p><code>???.js</code>中，<code>onLoad(仅1) onShow onReady(渲染完成 仅1) onHide onUnload(仅1)</code></p></blockquote></li></ul><h2 id="WXS脚本"><a href="#WXS脚本" class="headerlink" title="WXS脚本"></a>WXS脚本</h2><h4 id="WXS概念"><a href="#WXS概念" class="headerlink" title="WXS概念"></a>WXS概念</h4><p>结合wxml构建页面的结构，用于渲染页面结构</p><blockquote><p>wxml无法直接调用js定义的函数，但可以调用wxs函数。<em>过滤器</em></p></blockquote><ul><li>语法<blockquote><p>数据类型：类似JS，<br>语法形式：<br>不支持<code>let const 解构赋值 展开运算符 箭头函数 对象属性简写</code> ES6以上<br>支持<code>var function</code> ES5语法<br>CommonJS规范：</p><ol><li>模块引用（<code>require()</code> 方法）：用于在一个模块中引用另一个模块。</li><li>模块定义（<code>module.exports</code> 或 <code>exports</code> 对象）：用于定义模块中的函数、变量或对象，并将其导出到其他模块中。  </li><li>模块标识符（<code>module.id</code> 属性）：用于唯一标识一个模块，以便在其他模块中引用和调用。  </li><li>模块循环依赖（<code>require()</code> 方法缓存机制）：用于解决模块之间的循环依赖问题，避免模块引用和导出出现死循环。</li></ol></blockquote></li></ul><h4 id="WXS-基本语法"><a href="#WXS-基本语法" class="headerlink" title="WXS 基本语法"></a>WXS 基本语法</h4><ul><li>内嵌wxs脚本<blockquote><p>在wxml通过<code>&lt;wxs&gt;</code>标签实现<br>每个<code>&lt;wxs&gt;&lt;/wxs&gt;</code> 必须提供<code>module</code>属性来命名wxs模块，wxml通过名称访问对应模块成员</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;m1.toUpper(userName)&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- userName在js中定义--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">&quot;m1&quot;</span>&gt;</span></span><br><span class="line">module.exports.toUpper = function(str)&#123;</span><br><span class="line">return str.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">wxs</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- module.exports.toUpper使函数导出，使之向外共享可被调用或引用 --&gt;</span></span><br></pre></td></tr></table></figure></li><li>外联wxs脚本<blockquote><p>代码编写在<code>???.wxs</code>文件中，<em>放utils文件下</em>。<br>引入时，<code>&lt;wxs src=&quot;路径&quot; module=&quot;命名&quot;&gt;&lt;/wxs&gt;</code></p></blockquote></li><li>使用特点<blockquote><p><code>过滤器</code>，用于<code>Mustache</code>；<br>不可用于<code>回调函数</code>，如<code>&lt;button bindtap=&quot;xxx&quot;&gt;???&lt;/button&gt;</code><br>无法调用小程序api和js函数<br>ios设备上性能比js快</p></blockquote></li></ul><h2 id="案例实操2"><a href="#案例实操2" class="headerlink" title="案例实操2"></a>案例实操2</h2><h4 id="动态请求"><a href="#动态请求" class="headerlink" title="动态请求"></a>动态请求</h4><ul><li>普通的请求url是静态的，编写完直接决定。根据需要动态请求<code>wx.request</code> ,url中在对应需要请求的参数用<code>&amp;&#123;this.data.???&#125;</code>替代来动态请求。</li></ul><h4 id="页面加载"><a href="#页面加载" class="headerlink" title="页面加载"></a>页面加载</h4><ul><li>判断页面加载完成。<code>if(page*pageSize &gt;= total) return wx.showToast(&#123;title:&quot;加载完毕&quot;，icon:&#39;none&#39;&#125;)</code></li><li>页面刷新时，重置<code>page</code> <code>total</code> <code>list</code> 等数据</li></ul><h4 id="WXS处理格式-手机号"><a href="#WXS处理格式-手机号" class="headerlink" title="WXS处理格式 手机号"></a>WXS处理格式 手机号</h4><ul><li>在wxs中通过，<code>var arr=str.split</code>以及<code>arr.splice(位置，删除个数，插入元素)</code></li></ul><h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><ul><li>组件的创建<blockquote><p>与页面同级别，创建法类似。创建完成要在app.json建立联系</p></blockquote></li><li>引用组件<blockquote><p>全局引用：<code>app.json</code>的<code>usingComponents&#123;&quot;组件名&quot;:&quot;/组件路径&quot;&#125;</code><br>局部引用：<code>xxx.json</code>的<code>usingComponents&#123;&quot;组件名&quot;:&quot;/组件路径&quot;&#125;</code></p></blockquote></li><li>组件与页面区别<blockquote><p>组件的json文件要申明<code>&quot;component&quot;:true</code><br>组件的js文件要调用<code>Component()</code><br>组件的事件处理写在<code>method:&#123;&#125;</code>结点中</p></blockquote></li><li><strong>组件样式的隔离</strong><blockquote><p>组件样式的隔离性：只对当前组件生效，对外部UI结构无影响<br>全局样式<code>app.wxss</code>对组件样式无效<br>选择器：class有隔离效果；id、属性、标签选择器无样式隔离；<strong>组件和引用组件用class选择器</strong></p></blockquote></li><li><strong>修改组件样式的隔离选项</strong><blockquote><p>法一:组件Js文件的options对象中<code>Component(&#123;options:&#123;styleIsolation:&#39;isolated&#39;&#125;&#125;)</code><br>法二:组件Json文件增加<code>&#123;&quot;styleIsolation&quot;:&quot;isolated&quot;&#125;</code><br><code>isolated</code>隔离 默认<br><code>apply-shared</code>受页面的wxss影响；组件样式不影响页面<br><code>shared</code>受页面的wxss影响；组件样式影响页面、非isolated组件</p></blockquote></li><li>自定义组件data数据<blockquote><p>data是组件内部私有数据，相较之下properties是外部给组件的数据。本质指向同一个对象</p></blockquote></li><li>自定义组件method方法<blockquote><p>规范：自定义方法用下划线开头</p></blockquote></li><li>自定义组件properties属性<blockquote><p>类似于button有bindtap，color等属性，组件属性properties可以接收外界传递到组件的数据<br>定义：在Js文件<code>Component(&#123;properties:&#123;...&#125;&#125;)</code>内部对象</p><blockquote><p>完整定义：<code>属性名:&#123;type:属性数据类型,Number:属性默认值&#125;</code><br>简便定义：<code>属性名：属性数据类型</code></p></blockquote></blockquote></li><li><strong>数据监听器observers</strong><blockquote><p>监听组件内属性和数据变化，启用处理函数<br>定义：在Js文件<code>Component(&#123;observers:&#123;...&#125;&#125;)</code>内部对象<br><code>&#39;n1,n2&#39;:function(newN1,newN2)&#123;this.setData(&#123;sum:newN1+newN2&#125;)&#125;</code><br>当监听对象属性时<code>n1=A.a n2=A.b</code> a改变；b改变；A改变 都会触发function<br>监听某个对象所有属性：通配符<code>**</code><br>e.g <code>&#39;A.**&#39;:function(obj)&#123;this.setData(&#123;操作obj.a,obj.b等&#125;)&#125;</code><br>技巧：<code>$&#123;&#125;</code>用来拼接字符串 e.g<code>&quot;he$&#123;ll&#125;o&quot; = &quot;hello&quot;</code></p></blockquote></li><li><strong>纯数据字段</strong><blockquote><p>不用于界面渲染的data字段，应用于不展示在界面以及组件传递。提升页面更新性能<br>使用：Js文件 <code>Component(&#123;options:&#123;...&#125;&#125;)</code> 中指定<code>pureDataPattern:正则表达式</code><br>e.g: <code>/^_/</code>以下划线开头的变量 <code>_a _b等</code>只能用于页面逻辑处理，提高性能</p></blockquote></li></ul><h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><p>![[Pasted image 20230803005759.png]]</p><blockquote><p><code>created</code>: 组件数据还未初始化，无法调用setData函数。只能添加一些自定义属性字段<br><code>attached</code>: 添加到页面节点树中，组件数据已经初始化，可以调用setData函数更新组件数据。<br><code>detached</code>: 组件被从页面节点树中移除，进行清洗性质工作。</p></blockquote><ul><li>定义：<code>lifetime</code>节点<br>![[Pasted image 20230803011306.png|500]]</li><li>组件所在页面的生命周期 <code>pageLifetimes</code>节点<blockquote><p>组件需要监听页面状态变化进行事件处理时，需要用到该页面的生命周期。<br><code>show</code>: 组件所在页面<strong>展示时</strong>执行<br><code>hide</code>: 组件所在页面<strong>隐藏时</strong>执行<br><code>resize</code>: 组件所在页面<strong>尺寸变化时</strong>执行<br>![[Pasted image 20230803012434.png|500]]<br>案例：页面出现时生成随机RGB颜色</p><blockquote><p><code>component(&#123;...&#125;)</code>下  method:{定义<code>_randomColor()&#123; this.setData &#125;</code>}<br><code>component(&#123;...&#125;)</code>下  pageLifetimes:{<code>show: function()&#123; 调用this.randomColor() &#125;</code>}<br>先在method中定义事件处理函数<br>再到pageLifetimes节点下对应页面生命周期函数下function调用<br>![[Pasted image 20230803013531.png|500]]![[Pasted image 20230803013559.png|500]]</p></blockquote></blockquote></li></ul><h2 id="自定义组件插槽"><a href="#自定义组件插槽" class="headerlink" title="自定义组件插槽"></a>自定义组件插槽</h2><blockquote><p>允许在组件内部定义一些占位符，以便开发者在使用组件时动态地传入一些内容。一个组件可包含多个插槽，每个插槽使用 <code>&lt;slot&gt;</code> 标签来定义。<br>代码顺序：自定义组件内封装好slot，页面使用时按照slot格式(<em>可以不填</em>)写需要传入的内容<br>渲染顺序：把页面代码要传入的内容替换组件的slot，然后再渲染组件<br>![[Pasted image 20230803014712.png|500]]</p></blockquote><ul><li>案例理解<br>自定义组件<code>my-component</code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>调用<code>my-component</code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">slot</span>=<span class="string">&quot;header&quot;</span>&gt;</span>这是组件的头部<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span>&gt;</span>这是组件的内容<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>定义<code>my-component</code> 的自定义组件，包含两个插槽：<code>header</code> 和默认插槽。其中，<code>header</code> 插槽使用 <code>name</code> 属性来指定插槽的名称，而默认插槽不需要指定名称。<br>使用时，<code>&lt;my-component&gt;</code> 标签包含了两个 <code>&lt;text&gt;</code> 节点，其中第一个节点传入了 <code>header</code> 插槽，第二个节点填充了默认插槽。</p></blockquote></li><li>插槽使用<blockquote><p>默认只能使用单个插槽，自定义组件有写slot也可以选择不传入。<br>启用多个插槽：组件Js &#x3D;&gt; Component &#x3D;&gt; options &#x3D;&gt; <code>multipleSlots：true</code><br>定义多个插槽：封装时通过<code>name</code>区分不同插槽；使用时节点额外增加一个属性<code>slot=name</code>指定。</p></blockquote></li></ul><p><code>my-component:</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;first&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>其他组件<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;second&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调用<code>my-component</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">slot</span>=<span class="string">&quot;second&quot;</span>&gt;</span>xxxxxxx<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">slot</span>=<span class="string">&quot;first&quot;</span>&gt;</span>aaabbbccc<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ul><li><strong>父子组件之间通信</strong><blockquote><p>父子组件：在组件组合中，包含子组件的组件为父组件，被包含在父组件中的组件称子组件。<br>属性绑定：通过在组件标签中设置属性值，将数据从<strong>父组件&#x3D;&gt;子组件</strong>。<br>事件绑定：通过在组件中触发事件，将数据从<strong>子组件&#x3D;&gt;父组件</strong>。<br>获取组件实例：通过<code>this.selectComponent()</code>获取子组件实例对象</p></blockquote></li><li><strong>属性绑定</strong> <em>父组件&#x3D;&gt;子组件</em><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-component</span> <span class="attr">message</span>=<span class="string">&quot;Hello, ChatGPT!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 子组件<span class="title class_">Js</span> --&gt;</span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">properties</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>父组件通过在 <code>&lt;child-component&gt;</code> 标签中设置 <code>message</code> 属性的值来传递数据，子组件通过 <code>properties</code> 属性来声明接收 <code>message</code> 属性，并在其中设置默认值。<br><em>子组件在父组件的数据传递 类似于 组件在页面中的使用。</em></p></blockquote></li><li><strong>事件绑定</strong> <em>子组件&#x3D;&gt;父组件</em> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;onButtonClick&quot;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 子组件<span class="title class_">Js</span> --&gt;</span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">onButtonClick</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;customEvent&#x27;</span>, &#123; <span class="attr">message</span>: <span class="string">&#x27;Hello, ChatGPT!&#x27;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-component</span> <span class="attr">bind:customEvent</span>=<span class="string">&quot;onCustomEvent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 父组件<span class="title class_">Js</span> --&gt;</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">onCustomEvent</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">detail</span>.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>子组件通过在 <code>&lt;button&gt;</code> 节点上绑定 <code>bindtap</code> 事件，并在事件处理函数中使用 <code>triggerEvent</code> 方法触发 <code>customEvent</code> 自定义事件，并传递了一个包含 <code>message</code> 属性的对象。<br>父组件在 <code>&lt;child-component&gt;</code> 标签上绑定 <code>bind:customEvent</code> 事件，并在事件处理函数中通过 <code>event.detail</code> 获取传递过来的数据。<br>步骤：</p><ol><li>父组件Js中，定义一个接收处理函数<code>onCustomEvent(e)</code>自定义事件传递给子组件</li><li>父组件html中，通过自定义事件引用<code>onCustomEvent</code>，用bind传给子组件事件<code>customEvent</code></li><li>子组件Js中，调用<code>this.triggerEvent(&#39;事件CustomEvent&#39;,&#123;传递的参数对象&#125;)</code></li><li>父组件Js中，通过形参获取数据对象<code>e.detail</code><br><em>简单来说就是子组件可以通过<code>this.triggerEvent</code>主动触发事件A并传递参数，只要使父组件绑定事件A就可以实现父组件接收子组件参数数据</em></li></ol></blockquote></li><li><strong>获取组件实例</strong><blockquote><p>父组件里调用<code>this.selectComponent(id或class选择器)</code> 获取子组件实例对象</p><ol><li>父组件html中，绑定事件处理函数<code>getChild()</code>; 子组件html中，选择器&#96;class&#x3D;”cA” id&#x3D;”iA”</li><li>父组件Js中，<code>getChild()&#123; const child = this.selectComponent(&#39;选择器&#39;);... &#125;</code></li></ol></blockquote></li></ul><h2 id="behaviors组件代码共享"><a href="#behaviors组件代码共享" class="headerlink" title="behaviors组件代码共享"></a>behaviors组件代码共享</h2><blockquote><p>behaviors，类似<code>Vue.js</code>中的“mixins”</p></blockquote><ul><li>behavior工作方式<blockquote><p>定义一组属性、数据、方法和生命周期函数，并被多个组件复用，从而实现代码的复用和模块化。一个 <code>behavior</code> 模块是一个包含属性、数据、方法和生命周期函数的 JavaScript 对象。<br>一个组件可以引用多个behavior，behavior也可引用其他behavior</p></blockquote></li><li>创建behaviors<blockquote><p>根目录下&gt;behaviors文件夹&gt;my-behavior.js</p></blockquote></li><li>用<code>Behavior(Object object)</code>方法定义实例对象，通过<code>module.exports</code>共享导出<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">Behavior</span>(&#123;</span><br><span class="line">  <span class="attr">properties</span>: &#123;</span><br><span class="line">    <span class="attr">myProperty</span>: <span class="title class_">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">myData</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">myMethod</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is my behavior method.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">lifetimes</span>: &#123;</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My behavior created.&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">attached</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My behavior attached.&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">detached</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My behavior detached.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>导入使用behavior<blockquote><p>组件Js中，使用<code>require()</code>方法导入实例对象，<strong>挂载后</strong>允许访问behavior中数据和方法。<br><code>const myBehavior = require(&quot;../../behaviors/my-behavior&quot;)</code>  </p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">behaviors</span>: [myBehavior],</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Do something in my component.&#x27;</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">myMethod</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>behavior可用节点<br>![[Pasted image 20230804020128.png|600]]</li><li>同名冲突字段的覆盖和组合规则<blockquote><p>组件和引用的behavior可以包含同名字段。处理规则按3中情况<br>同名数据字段data<br>同名属性properties或方法method<br>同名生命周期函数<br><em>具体参考微信小程序手册</em></p></blockquote></li></ul><h2 id="vant组件库"><a href="#vant组件库" class="headerlink" title="vant组件库"></a>vant组件库</h2><blockquote><p>一套小程序UI组件库</p></blockquote><ul><li>确保电脑中有npm环境，<code>在项目的资源管理器中右键打开黑窗口，然后输入命令&quot;npm init -y&quot;</code></li><li>安装vant<code>npm i @vant/weapp@版本号 -S --production</code></li><li>菜单栏 &gt; 工具 &gt; 构建npm</li><li>修改<code>app.json</code> 去除<code>&quot;style&quot;: &quot;v2</code> 防止样式冲突</li><li>在全局或局部json中添加 <em>以button为例，具体参考vant手册</em><blockquote><p><code>&quot;usingComponents&quot;: &#123;&quot;van-button&quot;: &quot;@vant/weapp/button/index&quot;&#125;</code></p></blockquote></li></ul><h4 id="CSS定制vant主题样式"><a href="#CSS定制vant主题样式" class="headerlink" title="CSS定制vant主题样式"></a>CSS定制vant主题样式</h4><ul><li>定义样式变量：变量前加<code>--</code> 如<code>--var1</code> </li><li>使用样式变量：利用<code>var()</code>引用变量 如<code>var(var1)</code></li><li>作用域：全局生效（<code>app.wxss</code>的<code>page&#123;...&#125;</code> ）<em>每个页面的根节点为page</em></li><li>vant的样式变量 <a href="https://github.com/youzan/vant-weapp/blob/dev/packages/common/style/var.less">配置文件</a></li></ul><h2 id="API的promise化"><a href="#API的promise化" class="headerlink" title="API的promise化"></a>API的promise化</h2><blockquote><p>小程序官方提供的异步API基于回调函数实现，容易造成”回调地狱“（可读，维护性差）<br><strong>Promise化</strong>：通过额外配置，把基于回调的异步API &#x3D;&gt; 基于Promise的异步API</p></blockquote><ul><li>API的Promise化的环境<blockquote><p>小程序根目录终端<code>npm install --save miniprogram-api-promise@1.0.4</code><br>删除原<code>miniprogram_npm</code> 工具 &gt; 构建</p></blockquote></li><li>API的Promise的实现<blockquote><p><code>promisifyAll</code> 函数的作用是将一个对象中的所有异步函数（以 <code>Async</code> 结尾）转换成 Promise 形式的函数。<br><em>（该方法需要导入<code>import &#123; promiseAll &#125; from &#39;miniprogram-api-promise&#39;</code>)</em><br>使用方法：<br><code>const wxp=wx.p=&#123;&#125;</code><br><code>promisifyAll(wx，wxp)</code> <br>promisifyAll把顶级对象wx promise化到 空对象wxp；而wxp和wx.p指向同一个对象，相当于Promise化到wx.p自身一部分上。后续调用可以使用wx.p直接进行</p></blockquote></li><li>调用Promise后的异步API<blockquote><p>以获取request信息为例：原：<code>wx.request(&#123;...&#125;)</code> 改：<code>wx.p.request(&#123;...&#125;)</code><br>返回值为一个Promise对象。<br><code>async</code> 关键字用于声明一个异步函数，异步函数在执行时会返回一个 Promise 对象。在异步函数中，可以使用 <code>await</code> 关键字来等待一个 Promise 对象的完成，并获取其结果。<br><em>如果只需要返回Promise对象中的某部分如data对象，可以把const res 改为 const {data:res} 最终打印出的res就会是返回Promise对象的data部分</em></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">getInfo</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> wx.<span class="property">p</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line"><span class="attr">method</span>:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line"><span class="attr">url</span>:<span class="string">&#x27;xxxxx.xxx&#x27;</span>,</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;zx&quot;</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="string">&quot;20&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="MobX全局数据共享"><a href="#MobX全局数据共享" class="headerlink" title="MobX全局数据共享"></a>MobX全局数据共享</h2><blockquote><p>用于解决组件间数据共享问题。数据共享方案: Vuex,Redux,MobX等<br>![[Pasted image 20230806002141.png|500]]</p></blockquote><ul><li>安装MobX相关包<blockquote><p><code>npm install --save mobx-miniprogram@4.13.2 mobx-miniprogram-bindings@1.2.1</code><br>删除miniprogram_npm文件夹，构建</p></blockquote></li><li>小程序的全局数据共享方案<blockquote><p><code>mobx-miniprogram</code>创建Store实例对象<br><code>mobx-miniprogram-bindings</code>把Store中的共享数据和方法，绑定到组件或页面中。</p></blockquote></li><li>创建Mobx的store成员<blockquote><p>根目录创建文件夹store &gt; <code>store.js</code> 创建实例对象<br><code>observable</code> 是 Mobx 库中的一个函数或装饰器，用于将普通的 JavaScript 对象或类属性转换为可观察对象。<br><code>action</code> 是一个用于对状态进行修改的函数或方法修饰器。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;observable,action&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-miniprogram&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">observable</span>(&#123;</span><br><span class="line">  <span class="comment">//数据字段</span></span><br><span class="line">  <span class="attr">numA</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">numB</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">//方法字段 计算属性（只读）</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">sum</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">numA</span>+<span class="variable language_">this</span>.<span class="property">numB</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//action方法字段 修改数据</span></span><br><span class="line">    <span class="attr">updataNum1</span>: <span class="title function_">action</span>(<span class="keyword">function</span>(<span class="params">step</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">numA</span> += step</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">updataNum2</span>: <span class="title function_">action</span>(<span class="keyword">function</span>(<span class="params">step</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">numB</span> += step</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>store成员绑定到页面中<blockquote><p>导入<code>createStoreBindings</code>方法和<code>store</code>实例<br><code>onLoad</code>周期创建<code>createStoreBindings(本页面对象this,参数数据对象)</code>,<br><em>this.storeBindings命名指向该对象</em><br><code>onUnload</code>周期清理<code>this.storeBindings.destroyStoreBindings()</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//页面(组件).js</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStoreBindings&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-miniprogram-bindings&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;store&#125; <span class="keyword">from</span> <span class="string">&#x27;../../store/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line"> <span class="title function_">onLoad</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storeBindings</span> = <span class="title function_">createStoreBindings</span>(<span class="variable language_">this</span>,&#123;</span><br><span class="line">      store,</span><br><span class="line">      <span class="attr">fields</span>: [<span class="string">&#x27;numA&#x27;</span>,<span class="string">&#x27;numB&#x27;</span>,<span class="string">&#x27;sum&#x27;</span>],<span class="comment">//要绑定的字段数据</span></span><br><span class="line">      <span class="attr">actions</span>: [<span class="string">&#x27;updataNum1&#x27;</span>]<span class="comment">//要绑定的方法</span></span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="title function_">onUnload</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">storeBindings</span>.<span class="title function_">destroyBindings</span>();</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>页面中使用Store成员<blockquote><p>直接通过Mustache语法使用field中的变量<br>组件通过定义属性<code>data-var1=&quot;&#123;&#123;???&#125;&#125;&quot;</code>，在该组件触发事件绑定时，事件处理函数通过参数target&gt;dataset&gt;var1<em>具体可以通过console.log(e)查询</em></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;numA&#125;&#125; + &#123;&#123;numB&#125;&#125; = &#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnHandler1&quot;</span> <span class="attr">data-step</span>=<span class="string">&quot;&#123;&#123;1&#125;&#125;&quot;</span>&gt;</span>numA+1<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnHandler1&quot;</span> <span class="attr">data-step</span>=<span class="string">&quot;&#123;&#123;-1&#125;&#125;&quot;</span>&gt;</span>numA-1<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">btnHandler1</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="comment">//console.log(e),</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">updataNum1</span>(e.<span class="property">target</span>.<span class="property">dataset</span>.<span class="property">step</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li>store成员绑定到组件中<blockquote><p>导入<code>createStoreBehavior</code>方法和<code>store</code>实例<br>定义一个数组<code>behaviors:[createStoreBehavior] 定义page对象</code>storeBinds:{store,fields:{…},actions:{…}}</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;storeBindingsBehavior&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-miniprogram-bindings&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;store&#125; <span class="keyword">from</span> <span class="string">&#x27;../../store/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">behaviors</span>: [storeBindingsBehavior],</span><br><span class="line">  <span class="attr">storeBindings</span>:&#123;</span><br><span class="line">    store,</span><br><span class="line">    <span class="attr">fields</span>:&#123;</span><br><span class="line">      <span class="attr">numA</span>:<span class="string">&#x27;numA&#x27;</span>,</span><br><span class="line">      <span class="attr">numB</span>:<span class="string">&#x27;numB&#x27;</span>,</span><br><span class="line">      <span class="attr">sum</span>:<span class="string">&quot;sum&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">actions</span>:&#123;</span><br><span class="line">      <span class="attr">updataNum2</span>:<span class="string">&#x27;updataNum2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure></li><li>组件中使用store成员<blockquote><p>见页面，同上</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;numA&#125;&#125; + &#123;&#123;numB&#125;&#125; = &#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnHandler2&quot;</span> <span class="attr">data-step</span>=<span class="string">&quot;&#123;&#123;1&#125;&#125;&quot;</span>&gt;</span>numB+1<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnHandler2&quot;</span> <span class="attr">data-step</span>=<span class="string">&quot;&#123;&#123;-1&#125;&#125;&quot;</span>&gt;</span>numB-1<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Components</span>(&#123;</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">btnHandler2</span>(<span class="params">e</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">updataNum2</span>(e.<span class="property">target</span>.<span class="property">dataset</span>.<span class="property">step</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h2><blockquote><p>可以优化小程序首次启动的下载事件；多团队开打更好的解耦协作<br>主包：启动页面，TabBar页面，所有分包用到的公共资源<br>分包：只包含和当前分包有关的页面和私有资源。<br>小程序<strong>启动时，默认下载主包并启动主包内页面</strong><br>进入<strong>分包某页面时，客户端下载对应分包</strong>，下载完成后再进行展示<br><strong>体积限制</strong>：整个小程序的所有包大小不超过16M；单个包的大小不超过2M</p></blockquote><ul><li>使用分包<blockquote><p><code>app.json</code>中<br><code>&quot;pages&quot;:[主包所有页面路径]</code>，<br><code>&quot;subpackages:[&#123;&quot;root&quot;:&quot;分包1根目录&quot;,&quot;pages&quot;:[分包1页面路径]&#125;,&#123;&quot;root&quot;:&quot;分包2根目录&quot;,&quot;name&quot;:&quot;分包别名&quot;,&quot;pages&quot;:[分包2页面路径]&#125;]&quot;</code></p></blockquote></li><li>引用分包<blockquote><p>主包无法引用分包私有资源，分包之间无法引用私有资源；私包可以使用主包公共资源</p></blockquote></li><li>独立分包<blockquote><p>分包的一种，但是可以独立于主包和其他分包单独运行，无需下载主包。<br>独立分包的页面启动速度快。<br><strong>配置独立分包</strong>，subpackages下root等统计设置<code>independent:true</code><br><code>app.json</code>&gt;<code>subpackages</code>&gt;<code>&#123;&quot;root&quot;...&quot;pages&quot;...,&quot;independent&quot;:true&#125;</code><br>独立分包相互隔绝，<strong>独立分包不可以引用主包公共资源</strong></p></blockquote></li><li>分包预下载<blockquote><p>预下载的分包页面启动速度更快。<br><strong>配置分包预下载</strong>：在<code>app.json</code>设置<code>preloadRule</code>节点<br><code>preloadRule:&#123;&quot;触发预下载的页面路径&quot;:&#123;&quot;network&quot;:&quot;网络模式&quot;,&quot;packages&quot;:[&quot;分包&quot;]&#125;&#125;</code><br>其中network可选”all”不限网络，”wifi”仅wifi环境<br><strong>下载限制</strong>：<em>同一个包的页面</em>共享<em>总的分包预下载限额为2M</em></p></blockquote></li></ul><h2 id="案例实操3"><a href="#案例实操3" class="headerlink" title="案例实操3"></a>案例实操3</h2><h4 id="自定义TabBar"><a href="#自定义TabBar" class="headerlink" title="自定义TabBar"></a>自定义TabBar</h4><ul><li>配置信息<blockquote><p><code>app.json</code>的tabBar项<code>&quot;custom&quot;:true</code>。<em>届时会覆盖<code>&quot;list&quot;</code>字段，但为了兼容版本不删除。</em></p></blockquote></li><li>添加tabBar组件<blockquote><p>新建文件夹<code>custom-tab-bar</code>,并在文件夹下创建一个component组件。</p></blockquote></li><li>编写tabBar组件<blockquote><p><code>app.json</code>引用组件。组件的wxml中编写组件，并修改对应js文件。<a href="https://vant-contrib.gitee.io/vant-weapp/#/tabbar">vant官方参考</a></p></blockquote></li><li>编写tabBar样式<blockquote><p>关键点：调试器的容器选择器，组件css样式变量，js中options共享styleIsolation</p></blockquote></li><li>tabBar的徽标<blockquote><p>组件中info属性，*<code>0 空格 &#39;&#39;</code>都不渲染*<br>关键点：引入mobx成员，挂载behaviors数组，数据绑定，监听某个变量变化处理info</p></blockquote></li><li>tabBar页面切换<blockquote><p>在组件的js文件中，监听事件处理函数调用<code>wx.switchTab</code>.<br>解决索引不符合问题：<strong>把索引<code>data</code>:active放在<code>store</code>公共区域。</strong><br><code>store.js</code><strong>定义</strong>：数据字段增加变量<code>activeTabBarIndex:0</code>以及更新方法<code>updataActiveTabBar:action(function(index)&#123;this.activeTabBarIndex = index&#125;)</code><br>tabBar组件页面js文件<code>storeBindings</code>节点的<code>fields</code>和<code>actions</code><strong>挂载</strong>增加的变量和方法，在<code>method</code>节点<strong>引用</strong>挂载后的名称，使得<code>onChange(event)</code>的参数索引event.detail能够传入store公共区域处理</p></blockquote></li></ul><h2 id="HBuilder联动"><a href="#HBuilder联动" class="headerlink" title="HBuilder联动"></a>HBuilder联动</h2><ul><li>下载HBuilder，运行&gt;运行设置&gt;连接到小程序所在文件位置</li><li>打开微信开发者工具，设置&gt;安全&gt;打开服务端口</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题导论</title>
      <link href="/2023/03/22/5.0-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/22/5.0-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>背包问题</strong></p><blockquote><p>从N个物品中选取放入到容量为M的背包中，每个物品价值$w_i$ 体积$v_i$，要求背包中价值最大</p></blockquote><p><strong>01背包</strong>[[5.1-01背包问题]]</p><blockquote><p>每件物品只能用一次</p></blockquote><p><strong>完全背包</strong>[[5.2-完全背包问题]]</p><blockquote><p>每件物品无限个</p></blockquote><p><strong>多重背包</strong>[[5.3-多重背包]]</p><blockquote><p>每件物品可用次数不同</p></blockquote><p><strong>分组背包</strong>[[5.4-分组背包]]</p><blockquote><p>n组物品，每组若干，每组只可选一个 </p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01背包问题</title>
      <link href="/2023/03/22/5.1-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/22/5.1-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230212144947.png|600]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>先从小规模的问题出发，寻找本质</strong></p><blockquote><p>设 背包容量$V$, 第 $i$ 件物品体积 $v_i$ 价值$w_i$<br>问题1：$V&#x3D;10;v_1&#x3D;4,w_1&#x3D;5;$<br>问题2：$V&#x3D;10;v_1&#x3D;4,w_1&#x3D;5;v_2&#x3D;5,w_2&#x3D;6$<br>问题3：$V&#x3D;10;v_1&#x3D;4,w_1&#x3D;5;v_2&#x3D;5,w_2&#x3D;6;v_3&#x3D;6,w_3&#x3D;7;$</p></blockquote><blockquote><p>问题1涉及到是否要选择物品1<br>问题2在选完了物品2后，就回到了问题1上，但此时场景为$V&#x3D;5$<br>同理，问题3选择物品后会回到问题1，问题2两个<strong>子问题</strong>上，只是场景不同</p></blockquote><blockquote><p>&#x3D;&#x3D;问题具有<strong>重叠子问题</strong>的性质。随着我们的选择，总是能遇到相应状态的子问题。&#x3D;&#x3D;<br>&#x3D;&#x3D;想求当前问题的最优解，就需要去保证子问题的最优解，因此他具备<strong>最优子结构的性质</strong>。&#x3D;&#x3D;<br>&#x3D;&#x3D;只面对物品1时的最优解，并不受物品2的影响。所以它也<strong>具备无后效性</strong>的性质。&#x3D;&#x3D;</p></blockquote><p>我们利用一个二维数组来存储问题，从最小的子问题一次一次增大规模，大规模问题可以直接获取已经解决的子问题的答案。</p><h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h3><p>动态规划需要我们<strong>提前记录好各个子问题的解</strong>，便于我们后续大规模问题的调用。</p><blockquote><p>1、不同子问题之间的转换关系（<strong>状态方程的表示</strong>）<br>2、如何有顺序地扩大子问题规模（<strong>循环的书写</strong>）</p></blockquote><h4 id="（1）状态方程"><a href="#（1）状态方程" class="headerlink" title="（1）状态方程"></a>（1）状态方程</h4><ul><li><p><strong>a.状态表示：</strong><br>假设物品选择规模是i个，此时的背包容量是j，那么可以将当前的问题状态表示为：<code>f(i,j)</code></p><blockquote><p>  $f(i,j)$:当面前共有i个物品，背包容量为j时，我们所能携带的最大价值。</p></blockquote></li><li><p><strong>b.状态转移</strong><br>状态转移就是表示出当前问题和子问题之间的关系。<br><strong>状态转移方程</strong>的书写思路就是：<strong>活在当下</strong>：通过当前的决策将问题的规模减少。 </p><blockquote><p>第 $i$ 物品的价值记作 $w[i]$ ,物品的体积记作 $v[i]$ 。</p></blockquote></li></ul><p>我们遇到了第i个物品，所以我们当下的事情第i个物品选或者不选。<br>两种情况下的最大值，就是我们的 $f(i,j)$ 的解。</p><blockquote><p>假设我们不选，那么此时的状态就只需要面对$i-1$个物品，背包容量也没变，即 $f(i-1,j)$<br>如果我们选了，那么此时的状态也只需要面对$i-1$个物品，但此时的容量和价值发生改变。</p></blockquote><p><strong>转移方程</strong> ：![[Pasted image 20230212155050.png|450]]</p><ul><li><strong>二维数组角度上看</strong> 本质就是一个&#x3D;&#x3D;枚举每一个点 $(i,j)$&#x3D;&#x3D; 一层层向上爬，直到走到第一行。<br><em>可移动范围就是左上，而上方&#x3D;&#x3D;(包括右上)&#x3D;&#x3D;所有的路都有计算过</em></li></ul><h4 id="（2）循环的设计"><a href="#（2）循环的设计" class="headerlink" title="（2）循环的设计"></a>（2）循环的设计</h4><blockquote><p>循环设计是为了<strong>能够及时计算出后续问题需要的子问题结果</strong>，并有序地存储起来。<br>以分析为例，后续问题中最后的子问题永远是第一个物品的选择，但面对第一个物品时容量不同。<br>因此可以<strong>先枚举出不同容量下，面对第一个物品的最优解</strong>。<br>然后<strong>再枚举同时面对第1，2个物品时，不同容量下的最优解</strong>。<br>以此类推…</p></blockquote><h2 id="朴素代码"><a href="#朴素代码" class="headerlink" title="朴素代码"></a>朴素代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],v[N],w[N];<span class="comment">// 转移方程 物品数量 物品价值</span></span><br><span class="line"><span class="type">int</span> n,m;<span class="comment">// 物品个数 背包容量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,v+i,w+i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举背包规模 显然f(0,0~m)都为0，无需初始化，从1开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)<span class="comment">//枚举对象相同，但不同容量情况的选法0~m</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//书写状态方程</span></span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j]; <span class="comment">//不选i时的f的价值最大值</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i]) <span class="comment">//选i时判断剩余容量</span></span><br><span class="line">            f[i][j]=max(f[i<span class="number">-1</span>][j-v[i]]+w[i],f[i][j]); <span class="comment">//选i和不选i的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空间优化代码"><a href="#空间优化代码" class="headerlink" title="空间优化代码"></a>空间优化代码</h2><p><strong>如何节省&#x3D;&#x3D;空间&#x3D;&#x3D;</strong></p><blockquote><p>二维数组角度上看，首先就第一层来说，由于并不知道下面的点走到上面时j会减少到多少，至多m<br><strong>因此 j 从 0~m 都需要遍历</strong><br>由于元素是一层一层往上走的，加上每次用都是上一行的元素，只需要 选择$v_i$ $w_i$变量。<br><strong>本质就是走n次</strong><br>由于当前问题的子问题都存储在了二维数组的上一行，再往上的子问题记录就没有用了，只是多占空间而已。<br>只需要一个<strong>一维数组</strong>。只需要<strong>来回覆盖</strong>。 就可以代替原来的二维数组。</p></blockquote><p>使用的空间如下（<em>看个大概就行</em>）：![[FC77CAA98F0C3C8F13FE9F665D2E1EE2.png|550]]<br><em>选择第$i$个物品就是跳格子斜走，不选就只是上移</em></p><blockquote><p><strong>用一个长度为m的一维dp数组 $f[j]$ $表示当前的背包容量为j时的价值$</strong></p></blockquote><blockquote><p>而一维数组有限，<strong>只有需要选择当前物品的格子，会有j和f值的变动</strong>，<strong>不选j和f都不变</strong><br>意思就是说$j &gt;&#x3D; v_i$都会更新,而 $j&lt;v_i$ 都不需要更新<br>不妨让背包从一开始就是容量最大，每行枚举左走，走到当背包容量不够$v_i$就下一行。(不选不需要更新)<br>所以我们采取<strong>逆序覆盖</strong>。</p></blockquote><blockquote><p>如果采取正序覆盖, <strong>$j$ 从0开始一直到 $v_i$ 都不需要更新</strong>。<br>同时从二维数组来看，由于当前格$(i,j)$如果要更新必定会用到上一行左侧的某个元素，而放在一维数组中，同时由于是正序，当前要处理的元素左侧都已经被覆盖过了,<em>覆盖后对应二维(i,1~j-1)</em> 而我们更新需要用到的是覆盖前第$i-1$行的这些元素，<strong>从左开始会把更新需要用到的元素提前覆盖掉</strong></p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;<span class="comment">//物品数量 背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,v+i,w+i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举背包规模</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)<span class="comment">//枚举容量</span></span><br><span class="line">            f[j]=max(f[j-v[i]]+w[i],f[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>状态压缩DP</title>
      <link href="/2023/03/22/5.10-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
      <url>/2023/03/22/5.10-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/</url>
      
        <content type="html"><![CDATA[<h1 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230219154005.png|500]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>注意到，只要放好横着的方块，竖着的方块的放法是唯一确定的，因此<strong>只需要考虑横放的方块</strong>。<strong>总方案数等于只放横着的小方块的合法方案数。</strong></p></blockquote><p>动规的核心思路就是<strong>枚举子问题</strong></p><blockquote><p>![[6490208E1CE264C5BE73433A05DBC0E5.png|300]]<br>让列数从小到大增大，列数较小的看作子问题。<br><em><strong>横放的方块看作，当前列的某几行延申到了下一列</strong></em><br><strong>注意</strong>：<strong>不可连续延申2次</strong>出现$1*3$方块的情况，同时<strong>两个横方块间行数需为偶</strong>防止竖块无法填满</p></blockquote><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态压缩</strong> :<strong>将一种状态压缩成二进制数</strong> 规定：1代表延申，0代表不延申。</p><blockquote><p>![[Pasted image 20230219164243.png|300x300]]<br>将上图中的<strong>一种状态压缩成了一个十进制数字 j</strong> 所以$j$ 就表示表格中的延申状态.<br>假设行数是5行，只需要从$00000$到$11111$去枚举每一种状态，然后我们判断是否合法即可。<br>而中间的状态枚举，即$j$ 写一个循环$0\sim2^5-1$<br>(<strong>所有状态：</strong> $000\dots00 \sim 111\dots11$)  <code>i = 0; i &lt; 1&lt;&lt;n ;i++</code><br>注意：*$j$不可以有连续奇数个0*；</p></blockquote><p><strong>状态表示：</strong> $$f[i][j]\ :第i列向第i+1列延申为j状态，至此i列所有方案数。$$</p><blockquote><p>最终状态：假设表格有k列，那么最终表示就是$f[k][0]$，意思就是第k列不延申到下一列。</p></blockquote><blockquote><p>就$i$列来看,$i-1$延申到$i$的状态表示为$k$, $i$到$i+1$为$j$,为避免$1<em>3$格子,<strong>要保证$k !&#x3D; j$</strong><br>同时要*<em>保证j的二进制数中不可以有奇数个0</em></em></p></blockquote><p><strong>状态转移：</strong>$$f[i][j]&#x3D;f[i][j]\  +\  f[i-1][k]$$</p><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><blockquote><p>外循环就是列数，内循环就是每一列可能的延申情况。<br>结束时输出$f[m][0]$ ：到达最后一列，并不再继续横放延申</p></blockquote><p><strong>初始化</strong>：</p><blockquote><p>事实从第1列开始枚举，但第1列判断冲突需要前一列，且一定不冲突，所以$i&#x3D;0;j&#x3D;0$ ;<br>$f[0][0]&#x3D;1$</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">15</span>,M=<span class="number">1</span>&lt;&lt;N;<span class="comment">//列数  状态数2^N个</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[N][M];<span class="comment">// 当前为第i列 状态为j 目前所有i列记录的方案数 </span></span><br><span class="line"><span class="type">bool</span> st[M];<span class="comment">//此状态是否合法</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m,n||m)<span class="comment">//不断输入棋盘行列大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; <span class="number">1</span>&lt;&lt;n;i++)<span class="comment">//遍历所有状态检查是否存在连续奇数个0</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//当前状态连续0的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j &lt; n;j++)<span class="comment">//n行，检查某列n个元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)<span class="comment">//当前位是1,连续0断开,进行一次连续0判断</span></span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) st[i]=<span class="literal">false</span>;<span class="comment">//连续奇数个0不合法</span></span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++;<span class="comment">//连续0，cnt加一</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) st[i]=<span class="literal">false</span>;<span class="comment">// 都到结尾，进行一次连续0判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">// 第1列开始，第0列只是虚构服务第1列，无方案不冲突，初始1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="comment">// 枚举所有共m列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt; <span class="number">1</span>&lt;&lt;n;j++) <span class="comment">// 枚举i列延申到i+1列所有状态</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt; <span class="number">1</span>&lt;&lt;n;k++) <span class="comment">// i-1列延申到i列所有状态</span></span><br><span class="line">                    <span class="keyword">if</span>(!(j&amp;k)&amp;&amp;st[j|k]) <span class="comment">// 如果j k不冲突 且 连续0合法</span></span><br><span class="line">                    dp[i][j]+=dp[i<span class="number">-1</span>][k];<span class="comment">// 该方案可下一列继续</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[m][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//到最后一列不应该再向外延伸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230220085230.png|500]]</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><blockquote><p>汉密尔顿图：经过每个节点恰好一次</p></blockquote><blockquote><p>我们求最短路是通过<strong>松弛</strong>操作进行的，就对一条走完所有点的路径而言，最后一个点为j，倒数第二个点为k，我们已知$w[j][k]$，并尝试逆推往回求出0到k的最短路径。<strong>不断反向递归</strong>，直到路径只有2个点走过时，k只能表示0本身，0到k的最短路径不言而喻。<em>事实上是贪心思想</em></p></blockquote><h3 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong>——状态压缩</p><blockquote><p>有一个变量$j$ 表示当前状态到达的点，<br>到达$j$点时经过的点的记录$i$ ，防止漏点或重复，利用二进制数$i$表示路径$$f(i,j):到达点j时通过路径为i的最短路径长度$$<br>二进制表示000…00 ~ 111…11 走完为止 即<code>i = 0; i &lt; 1&lt;&lt;n ;i++</code><br><em>e.g. 比如走过了 0，1，5，4号点 共 8个点 则为00110011</em></p></blockquote><p><strong>状态转移</strong></p><blockquote><p>设k为j的前一个点，$w(0,j)&#x3D;w(0,k)+w(k,j)$ 其中$w(k,j)$固定，<br><strong>本质就是通过松弛找到0到k的最短路径：</strong><br>![[Pasted image 20230220230255.png|300]]$$f[i][j]&#x3D;min(f[i][j]\ ,\ f[i-(1\ll j)][k]+w[k][j])$$$i\gg j$表示路径中点$j$ 对应的二进制数位置显示情况，$i\gg j\  &amp; \ 1$表示$i$记录的路径中是否经过$j$<br>$i−(1\ll j)$表示当前路中$j$点去掉的路径。k应该是当前走过路径的非j点，防止k会表示j</p></blockquote><h3 id="循环设计-1"><a href="#循环设计-1" class="headerlink" title="循环设计"></a>循环设计</h3><blockquote><p>由于最终的路径需要之前走过路的信息，所以<strong>没走完所有点的路径也需要<em>顺序</em>枚举</strong><br>对于某个路径，只能表示走过那些点，但并不知道最后一个是谁，所以<strong>路径内除了起点以外的所有点都要枚举</strong><br>同样的，松弛操作需要的倒数第二个点也不知道，<strong>除了0，j之外走过的其他点也需要枚举</strong></p></blockquote><blockquote><p>枚举所有路径，枚举该路径中已有的所有点j，（枚举）利用路径上其他点k，寻找0k最短路</p></blockquote><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">21</span>,M=<span class="number">1</span>&lt;&lt;N;</span><br><span class="line"><span class="type">int</span> f[M][N],g[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            cin&gt;&gt;g[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//从0走到0，0号点上二进制表示为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; <span class="number">1</span>&lt;&lt;n;i++)<span class="comment">//枚举所有路径情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)<span class="comment">//尝试枚举所有n个节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;&gt;j &amp; <span class="number">1</span>)<span class="comment">//如果这个点在这条路中</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)<span class="comment">//枚举路径中其他点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>((i-(<span class="number">1</span>&lt;&lt;j))&gt;&gt;k&amp;<span class="number">1</span>)</span><br><span class="line">                    &#123;<span class="comment">//找到0到k的最短路径</span></span><br><span class="line">                        f[i][j]=<span class="built_in">min</span>(f[i][j],f[i-(<span class="number">1</span>&lt;&lt;j)][k]+g[k][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][n<span class="number">-1</span>]&lt;&lt;endl;<span class="comment">//所有点都走完，且终点在n-1的那条路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树形DP</title>
      <link href="/2023/03/22/5.11-%E6%A0%91%E5%BD%A2DP/"/>
      <url>/2023/03/22/5.11-%E6%A0%91%E5%BD%A2DP/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230223190907.png|600]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于每个树的根节点，该问题可以转化为以该节点的子节点为根节点的子树的相同问题</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong></p><blockquote><p>$$f[u][1]：表示从所有以u为根节点的子树中选，并且选择u时的最大数值 $$$$f[u][0]：表示从所有以u为根节点的子树中选，并且不选择u时的最大数值$$</p></blockquote><p><strong>状态转移</strong><br>设父节点为$u$ 子节点为$s_i$<br>如果不选择u。那么子节点$s_i$可选或不选<br>如果选择u，子节点$s_i$都不可以选</p><blockquote><p>$$f(u,0) &#x3D; \sum\limits {max(f(s_i, 0) , f(s_i,1))}$$$$f(u,1) &#x3D; \sum\limits {f(s_i, 0)}$$</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;<span class="comment">//邻接表存树</span></span><br><span class="line"><span class="type">int</span> hap[N];<span class="comment">//每个人的高兴值</span></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    f[u][<span class="number">1</span>]=hap[u];<span class="comment">//选根节点 加上该节点的高兴度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];<span class="comment">// 子节点</span></span><br><span class="line">        dfs(j);</span><br><span class="line">        f[u][<span class="number">0</span>]+=max(f[j][<span class="number">1</span>],f[j][<span class="number">0</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>]+=f[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//读入每个人的高兴度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;hap[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//初始化邻接表表头</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> root=<span class="number">1</span>;<span class="comment">//默认1为根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )<span class="comment">//读入所有边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<span class="comment">//子节点——父节点</span></span><br><span class="line">        add(b, a);</span><br><span class="line">        <span class="keyword">if</span>(a==root)root=b;<span class="comment">//替换父节点为根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(root);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;max(f[root][<span class="number">0</span>],f[root][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记忆化搜索</title>
      <link href="/2023/03/22/5.12-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
      <url>/2023/03/22/5.12-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230226132434.png|650]]<br>![[Pasted image 20230226132517.png|650]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于一条最优路径<code>a--&gt;b--&gt;c--&gt;d--&gt;y--&gt;x--&gt;i--&gt;d</code><br>可以从子最优路径<code>b--&gt;c--&gt;d--&gt;y--&gt;x--&gt;i--&gt;d</code> 直接得到，无需重复搜索<br>采用<strong>记忆化搜索</strong> </p><blockquote><p>直接记录搜索过的点所能达到的最大路程。<br>如果遇到相同的点，我们就直接返回我们记录的数据，终止重复搜索。</p></blockquote><p>$$f[i][j]:表示以(i,j)为起点的路径长度$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> h[N][N]; <span class="comment">// 每个点的高度</span></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    </span><br><span class="line">    f[x][y]=<span class="number">1</span>;<span class="comment">//默认每个点都是终点，不可走至少为1格，反向寻找最长路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++ )<span class="comment">//枚举四个方向</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a= x + dx[i],b = y + dy[i];</span><br><span class="line">        <span class="comment">//如果在界内 且 高度比当前小（可走）</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt;= <span class="number">1</span> &amp;&amp; a &lt;= n &amp;&amp; b &gt;= <span class="number">1</span> &amp;&amp; b &lt;= m &amp;&amp; h[a][b] &lt; h[x][y])</span><br><span class="line">        f[x][y]=max(f[x][y], dfs(a,b) + <span class="number">1</span>);<span class="comment">//不走和走之间的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//输入每个点高度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span> f);<span class="comment">//每个点-1都未算过</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//遍历每个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            res=max(res,dfs(i,j));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>完全背包问题</title>
      <link href="/2023/03/22/5.2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/22/5.2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230214234400.png|600]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><blockquote><p>相比01背包，完全背包中同一物品可以选择多次，仅受限于背包容量。01背包中，分为选i或者不选；而完全背包中可以划分更多区域：选0个，选1个，选2个，选3个… 选k个<br>这道题符合动态规划的三个性质：<strong>最优子结构</strong>，<strong>重叠子问题</strong>，<strong>无后效性</strong>。</p></blockquote><h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h3><blockquote><p>1、构建当前问题和子问题之间的关系：书写<strong>状态转移方程</strong>。<br>2、<strong>设计循环</strong>，记录每一个子问题的最优解</p></blockquote><h4 id="1、状态转移方程"><a href="#1、状态转移方程" class="headerlink" title="1、状态转移方程"></a>1、状态转移方程</h4><blockquote><p>要做的选择就是第i个物品，你到底是选还是不选，&#x3D;&#x3D;选几个&#x3D;&#x3D;。</p></blockquote><ul><li><strong>状态转移方程</strong>![[Pasted image 20230214234827.png|500]]</li></ul><h4 id="2、循环设计"><a href="#2、循环设计" class="headerlink" title="2、循环设计"></a>2、循环设计</h4><blockquote><p>循环的设计其实就是为了有条不紊地逐渐计算出规模不断增大地子问题。完全背包的循环设计和01背包的循环设计是一致的。我们逐一枚举1个物品时，各个容量下的最优解，2个物品时，各个容量下的最优解，直到n个物品下，各个容量下的最优解。</p></blockquote><h2 id="朴素代码"><a href="#朴素代码" class="headerlink" title="朴素代码"></a>朴素代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,v+i,w+i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)<span class="comment">//枚举不同剩余容量的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k*v[i]&lt;=j;k++)<span class="comment">//书写状态方程，每一种情况下选择数量</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+w[i]*k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间-空间优化代码"><a href="#时间-空间优化代码" class="headerlink" title="时间+空间优化代码"></a>时间+空间优化代码</h2><h3 id="（1）时间优化"><a href="#（1）时间优化" class="headerlink" title="（1）时间优化"></a>（1）时间优化</h3><blockquote><p>完全背包问题依旧是只利用 $i-1$ 行的数据</p></blockquote><blockquote><p>就状态转移方程而言<br> $f[i][j]&#x3D;f[i-1,j-v_i<em>k]+w_i</em>k$<br> ![[Pasted image 20230215234104.png|600]]<br> 第一行从第2个开始的每一项都和第二行的第1个开始的每一项对应，但彼此间大小不变<br> 即<strong>如果第一行的最大值确定为为$j-r<em>v$ $(r&gt;&#x3D;2)$项,则第二行最大值也为$j-r</em>v$项</strong></p></blockquote><blockquote><p>而$j$是从小到大遍历，所以第二行一定在第一行之前就得出后几项的最大值，所以<strong>可以省略k的遍历</strong><br>即本行的最佳策略在上一行子问题已经得到解决。</p></blockquote><p><strong>时间优化：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1100</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,v+i,w+i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i])</span><br><span class="line">            f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对比</strong></p><blockquote><p><strong>01背包：</strong>![[Pasted image 20230215235358.png|250]]<br><strong>完全背包：</strong>![[Pasted image 20230215235511.png|250]]<br>比较二者可以看出，<strong>完全背包</strong>面对$(i,j)$时，判断需要左上斜跳到$(i-1,j-v_i)$获取更新时，又由于$j$从小到大遍历，同行的$(i,j-v_i)$已经确定了物品数量的选择，所以跳到了&#x3D;&#x3D;同一行&#x3D;&#x3D;$(i,j-v_i)$<br>而<em>01背包</em>则是跳到了&#x3D;&#x3D;上一行&#x3D;&#x3D;$(i-1,j-v_i)$<br>考虑到<em>01背包优化空间</em>时$j$为<em>逆序覆盖</em>，综上又可以得出只需要&#x3D;&#x3D;<strong>正序覆盖</strong>&#x3D;&#x3D;就可以完成完全背包空间优化</p></blockquote><p><strong>进一步空间优化</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,v+i,w+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)<span class="comment">//正序覆盖</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i])</span><br><span class="line">            f[j]=max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分组背包问题</title>
      <link href="/2023/03/22/5.4-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/"/>
      <url>/2023/03/22/5.4-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230216175210.png|600]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>n组物品，每组若干，&#x3D;&#x3D;每组只可选一个&#x3D;&#x3D; </p></blockquote><blockquote><p>这道题符合动态规划的三个性质：<strong>重叠子问题，最优子结构，无后效性</strong>。<br>因此，我们可以使用动态规划的思路去解决这道题。动态规划我们需要思考两个问题：<br><strong>1、状态转移方程的书写 2、循环的设计</strong></p></blockquote><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><blockquote><p>状态$f(i,j)$表示的是&#x3D;&#x3D;共有$i$ 组物品，此时我们的背包容量为$j$ 的时候，我们所能携带的最大价值&#x3D;&#x3D;<br>$v[i][k]$ $w[i][k]$表示的是第 $i$ 组·第$k$ 个物品的容量 价值</p></blockquote><p>![[Pasted image 20230216195649.png|500]]</p><h3 id="循环的设计"><a href="#循环的设计" class="headerlink" title="循环的设计"></a>循环的设计</h3><blockquote><p>这里的循环还是和其他背包问题的设计方式一样，我们的最外层循环的是，我们所面对的物品<strong>组数</strong>，第二层循环枚举的是我们的容量。然后书写我们的状态转移方程。</p></blockquote><h2 id="朴素代码"><a href="#朴素代码" class="headerlink" title="朴素代码"></a>朴素代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],v[N][N],w[N][N],s[N];<span class="comment">//最大价值 i组j号物品容量和价值 第i组物品个数</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;<span class="comment">//组数 背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,s+i); <span class="comment">// i组内物品个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i][j],&amp;w[i][j]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">// 枚举所有组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)<span class="comment">// 枚举所有背包容量</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s[i];k++)<span class="comment">// 枚举组内所有物品的编号</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i][k]&lt;=j)</span><br><span class="line">                f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空间优化代码"><a href="#空间优化代码" class="headerlink" title="空间优化代码"></a>空间优化代码</h2><blockquote><p>基于01背包的空间优化可以把$f[i][j]$ 优化成 $f[j]$ </p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N],v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,s+i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i][j],&amp;w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)<span class="comment">//逆序覆盖</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s[i];k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i][k]&lt;=j)</span><br><span class="line">                f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性DP</title>
      <link href="/2023/03/22/5.5-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/03/22/5.5-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230217204712.png|600]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题有两种思路，可以自顶向下，而下面介绍自底向上</p><blockquote><p>这道题的情况太多了，太复杂了。而这种情况下，我们往往需要缩小问题的规模<br>![[Pasted image 20230217205246.png|500]]![[Pasted image 20230217205750.png|500]]<br>这个问题具备<strong>重叠子问题</strong>的性质。<br>同时在我们每次选择过后，问题的规模都会减小，但是我们依旧需要做出最优选择，此时说明这个问题具备<strong>最优子结构</strong>。<br>另外，我们解决大规模问题的时候，我们的小问题的最优解是没有发生变化的。而这种性质称作<strong>无后效性</strong>。<br>当一道题的问题满足上述三个性质的时候，我们通常可以使用<strong>动态规划</strong>的方式去解决。</p></blockquote><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong></p><blockquote><p>$f(i,j)$指的是，坐标为$(i,j)$的点向下走到底的时候，所能够经过路线的点的和的最大值。</p></blockquote><p>![[Pasted image 20230217215211.png|200]]</p><p><strong>状态转移</strong></p><blockquote><p>![[Pasted image 20230217214824.png|450]]</p></blockquote><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><blockquote><p><strong>相同规模的问题在同一行</strong>，<strong>最外层循坏是行数，第二层循环是列数</strong><br>一定是先从小规模的问题开始枚举，而最小规模的问题对应的是最大的下标。<strong>因此，我们只需要将第一层逆置过来即可，第二层是否逆置无所谓。</strong></p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N],a[N][N]; <span class="comment">// 各个坐标的值</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=max(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多重背包问题</title>
      <link href="/2023/03/22/5.3-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
      <url>/2023/03/22/5.3-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230216134233.png|600]] </p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><blockquote><p>相比完全背包，多重背包对于物品的选择有一定的次数限制，每个物品最大可选上限不同。<br>但这道题符合动态规划的三个性质：<strong>最优子结构</strong>，<strong>重叠子问题</strong>，<strong>无后效性</strong>。</p></blockquote><h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h3><blockquote><p>1、构建当前问题和子问题之间的关系：书写<strong>状态转移方程</strong>。<br>2、<strong>设计循环</strong>，记录每一个子问题的最优解</p></blockquote><h4 id="1、状态转移方程"><a href="#1、状态转移方程" class="headerlink" title="1、状态转移方程"></a>1、状态转移方程</h4><blockquote><p>前面的两篇文章中介绍过，对于背包问题而言，一般用一个二维数组来表示dp数组，即经常写的$f(i,j)$ 当物品数量为$i$，背包容量是$j$的时候，我们所能携带的最大价值：$f[i][j]$。</p></blockquote><h4 id="2、循环设计"><a href="#2、循环设计" class="headerlink" title="2、循环设计"></a>2、循环设计</h4><blockquote><p><strong>状态转移的目的是为了能够将大规模的问题转化成较小规模的问题。</strong></p></blockquote><h2 id="朴素代码"><a href="#朴素代码" class="headerlink" title="朴素代码"></a>朴素代码</h2><p>和完全背包几乎没有区别，最后一层k的循环中值条件需要额外增加<code>q[i]</code> </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],v[N],w[N],q[N];<span class="comment">//q[n]存储该物品可选数量最大值</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,v+i,w+i,q+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品规模</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)<span class="comment">//枚举背包容量</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k*v[i]&lt;=j&amp;&amp;k&lt;=q[i] ;k++)<span class="comment">//枚举所有可选数量</span></span><br><span class="line">            &#123;<span class="comment">//书写状态转移方程</span></span><br><span class="line">                f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><ul><li><p><strong>不能用完全背包的方法优化多重背包</strong></p><blockquote><p>在<strong>完全背包中</strong>，比较$f[i,j]$和$f[i,j-v_i]$ 时，max函数中的可列项<strong>完全取决于背包容量$j$</strong><br>所以$f[i,j]$的k+1项中除了第1项，后面k项和$f[i,j-v_i]$ 全部的k项对应<br><em>两者max函数各项：</em>![[Pasted image 20230216142146.png]]<br>但在<strong>多重背包中</strong>，max函数中的可列项<strong>同时还取决于物品 $i$ 可选上限 $s$</strong><br>也就是说，如果选取过程中$j$足够大,物品数量k先一步止步于s，那么$f[i,j]$ 和$f[i,j-v_i]$ 都是$s+1$项<br>错一位对应s项，会导致$f[i,j-v_i]$ 最后的s+1项多出来。</p><p>而$j$是递增迭代的，我们会先了解到$f[i,j-v_i]$中max函数s+1项中哪一项是最大的；等迭代到$f[i,j]$时我们需要用$f[i,j]$的max函数第1项和&#x3D;&#x3D;后面s项最大值比较&#x3D;&#x3D;，如果尝试借助$f[i,j-v_i]$中对应的前s项来求，但此时如果$f[i,j-v_i]$中max函数 第s+1项 为最大，就无法判断$f[i,j]$&#x3D;&#x3D;后s项&#x3D;&#x3D;最大值为哪一项了。</p><p><strong>所以多重背包并不适用完全背包的优化方法</strong></p></blockquote></li><li><p><strong>多重背包可以转化成01背包问题</strong></p><blockquote><p><strong>利用十进制数转化为二进制数</strong></p><blockquote><p>1,2,4,8 可以表示出0<del>15之间的任何数字。<br>对于0</del>200 1，2，4，8，…，64 可以表示 0<del>127 需要额外一个常数c&#x3D;73。<br>那么就可以表示73</del>200，这两部分重叠可以（且一定可以）覆盖0~200所有数字</p></blockquote><p>我们把第$i$种物品可选上限 $s_i$ 分成若干组，第一组1个，第二组2个，第三组4个…<br><strong>选几个可以转化为这些组每一个选或不选的问题</strong>，即01背包<br>![[Pasted image 20230216154245.png|500]]<strong>再利用01背包的空间优化，转化为一维数组进行处理</strong></p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;<span class="comment">//组数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,s;<span class="comment">//物品占容量 物品价值 物品上限</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;s);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行 “打包” 转换：二进制优化，转换成01背包</span></span><br><span class="line">        <span class="type">int</span> k=<span class="number">1</span>;<span class="comment">//每次把k个打包在一起</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt; s)</span><br><span class="line">        &#123;</span><br><span class="line">            v[cnt]=k*a,w[cnt]=k*b;<span class="comment">//打包成一个的 体积、价值</span></span><br><span class="line">            s-=k;<span class="comment">// 剩余可选上限</span></span><br><span class="line">            k*=<span class="number">2</span>;</span><br><span class="line">            cnt++;<span class="comment">//组数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)<span class="comment">//s_0 夹在2^n 和 2^(n+1)之间 直接处理剩余</span></span><br><span class="line">        &#123;</span><br><span class="line">        v[cnt]=s*a,w[cnt]=s*b;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用01背包中的空间优化模板求解。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)</span><br><span class="line">                dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性DP（2）</title>
      <link href="/2023/03/22/5.6-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2023/03/22/5.6-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230217220147.png|650]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>题目中组成递增子序列的元素可以不连续<br><strong>子序列的下一位填什么只和当前子序列的最后一位有关系。</strong><br><strong>只需要对具有相同最后一位的子序列中最长的子序列去进行后续的操作。</strong></p></blockquote><blockquote><p>一个最长子序列中包含很多子问题，因此它满足<strong>重叠子问题</strong>。<br>其次，我们每次都是让子序列中最长的去继续枚举，因此，它符合<strong>最优子结构</strong>的性质。<br>后续的选择，不会影响子问题的结果，因此，它也符合<strong>无后效性</strong>的性质。</p></blockquote><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong></p><blockquote><p>$f(i)$表示的是以$i$为结尾的子序列中的<strong>最长子序列的长度。</strong></p></blockquote><p><strong>状态转移</strong></p><blockquote><p>以当前数字$i$左侧的数字结尾的最长子序列就是$f(i)$的子问题。<br>由于子序列要求单调递增，**所以如果子序列中的最后一个数小于$i$，那么就能够选$i$**，此时这个序列的长度也加上了1。<br>然后在这些序列中取出一个最大值，我们就能找到以$i$为结尾的子序列的最大值。<br>![[Pasted image 20230217225420.png|300]]</p></blockquote><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><blockquote><p>循环很简单，就是从左遍历序列即可。</p></blockquote><blockquote><p><strong>注意</strong>：最终得到的是不同数字结尾的子序列最大值。但是题目中并没说以哪个数字为结尾，题目只需要一个最大值，因此，<strong>需要再在这些以不同数字结尾的子序列的最大值中取出一个最大值。</strong></p></blockquote><h2 id="代码-O-n-2"><a href="#代码-O-n-2" class="headerlink" title="代码 $O(n^2)$"></a>代码 $O(n^2)$</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> dp[N],a[N];<span class="comment">//i结尾的子序列长度最大值</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//从左遍历i为结尾的子序列。</span></span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;<span class="comment">//只有一个元素a[i]的时候，子序列的长度为1，设置为默认值。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)<span class="comment">//状态转移方程。</span></span><br><span class="line">        &#123;<span class="comment">//前面的数是否能和i构成子序列</span></span><br><span class="line">           <span class="keyword">if</span>(a[j]&lt;a[i]) dp[i]=max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//此事dp[i]中存储着所有i结尾的最大上升子序列</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//再次循环，挑出最大值。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = max(res, dp[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_72060925/article/details/128429202?spm=1001.2014.3001.5502">最长上升子序列优化（贪心+二分）</a> </p><h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><p>![[Pasted image 20230315180702.png|650]]</p><ul><li>朴素思路为<blockquote><p>枚举主序列所有元素$a[i]$<br>枚举$a[i]$ 之前所有的元素<br>    &gt;如果该元素比$a[i]$小 那么以该元素为结尾的子序列长度+1更新为$a[i]$结尾子序列长度</p></blockquote></li></ul><blockquote><p>其中枚举$a[i]$前面的元素时，对于以它们结尾的子序列来说，如果长度相同，优先选择结尾元素比较小的序列为优（上升空间更大）<br>该循环可以用一个二分查找</p></blockquote><p>综上，时间复杂度为$O(nlogn)$ </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = max(len, r + <span class="number">1</span>);</span><br><span class="line">        q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数位统计DP</title>
      <link href="/2023/03/22/5.9-%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/"/>
      <url>/2023/03/22/5.9-%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230226135601.png|650]]<br>![[Pasted image 20230226135622.png|650]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>求区间$[a,b]$中x出现的次数，利用<strong>前缀和</strong>思想，求1<del>a-1和1</del>b区间x出现的次数做差。<br>因此只需要一个count(n,x)函数求出1~n中x的次数即可。</p><blockquote><p>e.g. count(n , 1)  假定n&#x3D;7<br>    分别求出1在每一位上出现的次数<br>    设n的表示为 $n&#x3D;abcdefg$ , 比如1<del>n中表示的第四位形式为 xxx1yyy<br>    要使：<em>1 &lt;&#x3D; xxx1yyy &lt;&#x3D; abcdefg</em><br>    1) xxx &#x3D; 000</del>abc-1 , yyy &#x3D; 000<del>999 , 共$abc*1000$种选法<br>    2) xxx&#x3D; abc, yyy：<br>        <del>2.1) d &lt; 1 : 要使得 abc1yyy &lt; abc0efg 共0种可选</del><br>        2.2) d &#x3D; 1 : yyy &#x3D; 000</del>efg1 共$efg+1$种选法<br>        2.3) d &gt; 1 : yyy &#x3D; 000<del>999 共$1000$种<br>    3) xxx &gt; abc 显然不可能<br><strong>注意：</strong><br><em>（讨论第一位时，1yyyyyy， 类型1 不存在）</em><br>*对于类型1中，如果求0的出现次数，则高位xxx的范围是001</del>abc-1*</p></blockquote><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><blockquote><p>枚举总共10个数字</p><blockquote><p>算2个区间做差</p><blockquote><p>本题范围内每一位共8位</p><blockquote><p>分类讨论，最多每一位都讨论10遍</p></blockquote></blockquote></blockquote></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">001~abc-1, 999</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">    1. num[i] &lt; x, 0</span></span><br><span class="line"><span class="comment">    2. num[i] == x, 0~efg</span></span><br><span class="line"><span class="comment">    3. num[i] &gt; x, 0~999</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; num, <span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//l~r位映射到数字上用于比较</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &gt;= r; i -- ) res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">power10</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//给予相应的位权 10的i次方</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x -- ) res *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span><span class="comment">// 求出1~n中x出现的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">    <span class="keyword">while</span> (n)<span class="comment">//按位放入num</span></span><br><span class="line">    &#123;</span><br><span class="line">        num.push_back(n % <span class="number">10</span>); <span class="comment">//num&#123;ge,shi,bai,qian,...&#125;</span></span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = num.size();<span class="comment">// 位数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span> - !x; i &gt;= <span class="number">0</span>; i -- )<span class="comment">//如果x=0，当前位i从n-2开始循环</span></span><br><span class="line">    &#123;<span class="comment">// 分类讨论</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>)<span class="comment">//类型1只对非最高位时，方案存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            res += get(num, n - <span class="number">1</span>, i + <span class="number">1</span>) * power10(i);</span><br><span class="line">            <span class="keyword">if</span> (!x) res -= power10(i);<span class="comment">//讨论0个数时,高位范围从001~abc-1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num[i] == x) res += get(num, i - <span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;<span class="comment">//类型2.2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[i] &gt; x) res += power10(i);<span class="comment">//类型2.3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b , a || b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i ++ )<span class="comment">//类前缀和处理法</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; count(b, i) - count(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性DP（3）</title>
      <link href="/2023/03/22/5.7-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/03/22/5.7-%E7%BA%BF%E6%80%A7DP%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230218132138.png|550]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最终答案为3 即abd</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong></p><blockquote><p>涉及到了2个字符串，$f(i,j$)：从左向右，以第$i$个字母结尾的字符串1和以第j个字母结尾的字符串2之间最长的公共子序列的<strong>长度</strong></p></blockquote><p><strong>状态转移</strong><br>从左到右依次从两个字符串中选取两个字符$a[i]$ $b[j]$<br>    <strong>$f[i][j]$更新为</strong></p><blockquote><ol start="0"><li><p>$a[i],b[j]$ 都不选：$f[i-1][j-1]$  <em>&#x2F;&#x2F;$a[i],b[j]$都不在公共子序列中</em> </p></li><li><p>$a[i],b[j]$ 都选：$f[i-1][j-1]+1$ <em>&#x2F;&#x2F; 此时显然有$a[i]&#x3D;b[j]$的前提</em></p></li><li><p>选$a[i]$，不选$b[j]$ ：表示$a[i]$一定在子序列中，<em>但$f[i][j-1]$并不能保证$a[i]$在子序列中</em></p></li><li><p>不选$a[i]$，选$b[j]$ ：表示$b[i]$一定在子序列中，<em>但$f[i-1][j]$并不能保证$b[i]$在子序列中</em></p></li></ol><p>显然 $f[i][j-1]$ 和 $f[i-1][j]$ 情况实际上包括了00 01 10情况的子序列</p></blockquote><p><strong>由于不涉及到<em>数量</em>，即便有重复的情况也没有关系</strong></p><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j]=max(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]); </span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j]) f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性DP（4）</title>
      <link href="/2023/03/22/5.8-%E5%8C%BA%E9%97%B4DP%E2%80%94%E2%80%94%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/"/>
      <url>/2023/03/22/5.8-%E5%8C%BA%E9%97%B4DP%E2%80%94%E2%80%94%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>![[Pasted image 20230218143716.png|550]]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>经典的DP问题。<br>之前的dp问题都是用$i−1$的规模的子问题来求解当前的问题。<br>其实，类似于贪心，不断地做对当下最好的选择<br>比如之前的背包问题、子序列问题，都是看的最后一个元素，只做出当下最好的选择，而体现出做最好选择的部分就是通过比较选出最大值最小值的代码。</p></blockquote><blockquote><p>但是这道题不一样，这道题将带给我们新的理解。<br>如果说之前的问题是贪心+DP，那么这个问题就是<strong>分治+贪心+DP</strong>。<br>其中DP决定了我们这道题的框架，而前面的算法决定了我们书写状态转移方程的依据</p></blockquote><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><strong>状态表示</strong></p><blockquote><p>$f(i,j)$ 表示合并第$i$堆到第$j$堆石子所需要的最小代价，区间$[i,j]$</p></blockquote><p><strong>状态转移</strong></p><blockquote><p>从结果要合并成一整堆来看，最后一步由两个分堆合并成一个。<br>分治的思想：（黑线表示合并两大堆石子的最优选择。）![[Pasted image 20230219115303.png|300]]<br>同样的，过程中任意某一堆$[i,j]$区间的d堆石子，分法有：(1,d-1) ; (2,d-2) ; (3,d-3) ; …;不合并<br>合并前，设左堆$[i,k]$,右堆$[k+1,j]$ ，则$[i,j]$区间的最小代价为：$$f(i,j) &#x3D; min(f(i,k)+f(k+1,j)+S[i,j]\ \ ,\ \  f(i,j))$$<em>$S[i][j]$表示两堆石子的总质量，即$[i,j]$所有石子重量，可以用</em><strong>前缀和</strong><em>表示$s[i]-s[j]$</em><br>$k$表示所有可能合并两堆石子的位置，上述k循环$i\sim j-1$即可得到该区间最小代价</p></blockquote><h3 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h3><p><strong>循环</strong></p><blockquote><p>从最小的子问题开始，合并两堆未合并过的石子，区间长度是2。要枚举出所有可能合并的情况<br>外循环$i$负责区间的长度，内循环负责所有区间长度为$i$的情况，并计算出代价。</p></blockquote><p><strong>初始化</strong></p><blockquote><p> f 数组是全局变量，因此就都初始化为0，之前的问题由于是求最大值所以无需修改<br>要求最小的子问题，需要初始化成最大。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];<span class="comment">//[i,j]区间内最小合并代价</span></span><br><span class="line"><span class="type">int</span> s[N];<span class="comment">//前缀和</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        s[i]=x+s[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)<span class="comment">//区间长度len从小到大开始枚举</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;i++)<span class="comment">//枚举所有长度为len的区间的合并情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=i,r=i+len<span class="number">-1</span>;</span><br><span class="line">            f[l][r]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)<span class="comment">//长度为i的某个区间内的最小合并代价</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[l][r]=min(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——第一章</title>
      <link href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h4 id="重要内容"><a href="#重要内容" class="headerlink" title="重要内容"></a>重要内容</h4><blockquote><p>互联网边缘部分和核心部分的作用，以及分组交换的概念<br>计算机网络的性能指标<br>计算机网络的分层次的体系结构的概念，协议和服务的概念，</p></blockquote><h3 id="计算机网络的一些相关知识"><a href="#计算机网络的一些相关知识" class="headerlink" title="计算机网络的一些相关知识"></a>计算机网络的一些相关知识</h3><blockquote><p><strong>三网</strong>——电信网络，有线电视网络，计算机网络<br>三网融合——将三种网络的功能融合在一起<br>计算机网络：也是一种通信基础设施，与其他两种网络不同的是计算机网络的端设备是功能强大的计算机，两个重要的功能：<strong>连通和共享</strong></p></blockquote><h3 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h3><blockquote><p><strong>互联网（因特网）：</strong> 起源于美国的因特网现在是世界上最大的国际性计算机网络<br><strong>计算机网络</strong>：由若干节点和连接这些节点的链路组成（节点可以是计算机，集线器，交换机，路由器等）<br><strong>互连网</strong>：网络和网络之间通过路由器连接起来——即网络的网络</p></blockquote><blockquote><p>因此，网络把许多计算机连接在一起，互连网将许多网络连接在一起，互联网则是特指专用名词</p></blockquote><p>互联网发展的三个阶段——</p><blockquote><p>第一阶段：单网络ARANET——1969年美国国防部建立的第一个分组交换网<br>第二阶段：三级结构的因特网——主干网，地区网，校园网<br>第三阶段: 多层次IPS（因特网服务提供者）结构的因特网</p></blockquote><p>ISP(互联网服务提供者)</p><blockquote><p>ISP可以申请到IP地址，拥有通信线路和路由器等连网设备<br>主干ISP、地区ISP、本地ISP<br>![[Pasted image 20230307214211.png|450]]</p></blockquote><p>因特网交换点IXP——（更快的转发分组，更有效地利用网络资源）允许两个网络直接相连并对等交换分组，不需要其他网络来转发分组，IXP常采用工作在数据链路层的网络交换机，这些网络交换机都用局域网互连起来（典型的IXP由一个或多个网络交换机组成，）</p><p><strong>因特网的标准化工作</strong></p><blockquote><p>所有的互联网标准都是以RFC的形式在互联网上发表的<br>ISOC——互联网协会<br>IAB——互联网体系结构委员会：负责协议开发<br>IETF——互联网工程部<br>IRTF——互联网研究部</p></blockquote><p>互联网标准形式：RFC（请求评论）<br>制定阶段：互联网草案 ——&gt; 建议标准（此时开始就是RFC了）——&gt; 互联网标准</p><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><blockquote><p><strong>边缘部分</strong>：连接在互联网上的<em>主机</em>组成，用户直接使用，通信共享。<br><strong>核心部分</strong>：由大量<em>网络</em>和连接这些网络的<em>路由器</em>组成，为边缘部分提供服务</p></blockquote><blockquote><p>边缘部分：<strong>端系统</strong>（主机）之间的通信是主机的<em>进程之间</em>——计算机之间通信。<br>端系统通信方式：<strong>客户&#x2F;服务器方式（CS方式</strong>）和 <strong>对等方式（P2P方式）</strong></p></blockquote><blockquote><p>核心部分：向网络边缘部分的主机提供连通性服务，其核心部件是实现分组交换的<strong>路由器</strong>（用来转发分组）</p></blockquote><p>两个概念：电路交换与分组交换</p><blockquote><p><strong>电路交换</strong>：建立连接——通话——释放连接（两个用户在连接期间始终占用端到端的通信资源）（连接指专用的物理通道）<em>线路传输数据快而占线多，大部分线路资源空闲，利用率低</em><br><strong>分组交换</strong>：存储转发，将报文（要发送的整块数据）划分为几个分组（<em>可以减少时延</em>），利用相关控制信息进行分装为数据单元 ，然后进行转发。<br>一个组的<strong>首部</strong>（包头）：存储目的地址和源地址。使得单个组可以独立自由地选择路线。</p></blockquote><blockquote><p><strong>总结：</strong> 端系统负责进行信息处理，路由器负责转发分组。</p></blockquote><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><blockquote><p><strong>1，按作用范围分</strong><br>广域网  WAN<br>城域网  MAN<br>局域网  LAN<br>个人区域网  PAN<br><strong>2，按网络的使用者</strong><br>公用网<br>专用网<br><strong>3，用来把端主机接入因特网的网络</strong><br>接入网</p></blockquote><h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><blockquote><p><strong>速率</strong>：数据率(比特率) <em>单位之间传输的比特位数</em><br>  <strong>带宽</strong>：<br>    (1) 本来指某个信号具有的频度带宽，信号（多种频率成分）占据的频率范围，单位：赫  <strong>频域</strong><br>    (2) <em>单位时间内信道能通过的最高数据率</em>，单位：比特每秒  <strong>时域</strong><br><strong>吞吐量</strong>：<em>单位时间内通过某网络（信道或者接口）的实际数据量</em><br><strong>时延:</strong> <em>数据从网络的一端传输到另一端所需要的时间</em> <strong>延迟或迟延</strong><br>    发送时延：发送端发送一个完整的数据帧所需要的时延<br>    传播时延：电磁波在信道中传播所需要的时间<br>    处理时延：主机或路由器处理数据分组时花费的时间<br>    排队时延：在路由器中等待分组时间<br><strong>时延带宽积</strong>——以比特为单位的链路长度：时延与带宽的乘积<br><strong>往返时间RTT</strong>：双方交互一次所需要的时间。<br><strong>利用率</strong>：包括信道利用率和网络利用率，<strong>利用率过高时延也会增加</strong><br>其他非性能特征</p></blockquote><h3 id="计算机网络的体系结构——分层次的体系结构"><a href="#计算机网络的体系结构——分层次的体系结构" class="headerlink" title="计算机网络的体系结构——分层次的体系结构"></a>计算机网络的体系结构——分层次的体系结构</h3><p><strong>SNA系统网络体系结构</strong><br><strong>OSI标准</strong>——由国际标准化组织制定的网络标准，但在实际应用中被TCP&#x2F;IP协议替代<br><strong>TCP&#x2F;IP协议</strong><br><strong>协议与划分层次——</strong></p><blockquote><p>网络协议：（明确规定交换数据的格式和有关同步问题）为进行网络中的数据交换而采取建立的规则，标准或约定<br><strong>三要素：语法   语义   同步</strong></p></blockquote><p><strong>具有五层协议的体系结构</strong>（结合OSI的七层协议体系结构和TCP&#x2F;IP的四层结构）</p><blockquote><p>应用层——通过应用进程间的交互来完成特定网络应用<br>运输层——向两个主机进程之间的通信提供通用的数据传输服务具有<strong>复用</strong>和<strong>分用</strong>的功能<br>····················（两种协议——<strong>传输控制协议TCP</strong>和<strong>用户数据协议UDP</strong>）<br>网络层——分装成数据包——IP数据报使用IP协议<br>数据链路层——分装成帧<br>物理层——考虑的是比特流的传输问题，屏蔽传输媒体的差异性</p></blockquote><p><strong>相关概念：</strong></p><blockquote><p>协议数据单元PDU：OSI参考模型为对等层次之间传送的数据单位的命名<br>实体：任何可以接受或者发送信息的软件进程或者硬件<br>协议：控制两个对等实体进行通信的规则的集合<br>在协议控制下，下层向上层提供服务，所以协议是水平的，服务是垂直的</p></blockquote><p><strong>TCP&#x2F;IP协议族示意图</strong><br>![[Pasted image 20230222102032.png|600]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——第二章</title>
      <link href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><h4 id="重要内容"><a href="#重要内容" class="headerlink" title="重要内容"></a>重要内容</h4><blockquote><p>物理层的任务<br>几种常用的信道复用技术<br>几种常用的宽带接入技术，主要是ADSL，FTTx</p></blockquote><h3 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><p>物理层的作用是<strong>屏蔽掉传输媒体和通信手段（即物理设备）的差异，让上层的链路层不必考虑物理层差异。</strong> 物理层协议——<strong>规程</strong><br>物理层的主要任务</p><blockquote><p><strong>确定与传输媒体的接口有关的一些特性</strong><br>1）机械特性：指明接口的尺寸形状等物理适配。<br>2）电气特性：指明接口电缆各线的电压范围<br>3）功能特性：指明线上某一电平的电压意义<br>4）过程特性：指明事件出现顺序<br>完成数据在<strong>计算机内部（并行传输）</strong> 与 <strong>通信线路上（串行传输）</strong> 之间的串并传输方式的转换</p></blockquote><h3 id="数据通信的基本知识"><a href="#数据通信的基本知识" class="headerlink" title="数据通信的基本知识"></a>数据通信的基本知识</h3><p><strong>1）数据通信系统的模型</strong><br><strong>源系统——传输系统——目的系统</strong><br>![[Pasted image 20230315005705.png|500]]</p><blockquote><ol><li><strong>源系统（源点，发送器）</strong><br>源点：源点设备要传输的数据<br>发送器：源点比特流的的<strong>调制器</strong>，转化为信号</li><li><strong>传输系统（传输线或者网络）</strong></li><li><strong>目的系统（接收器，终点）</strong><br>接收器：接受传输系统的信号并转化为目的设备处理的信息的<strong>调制器</strong><br>终点：获取接收器的数字比特流</li></ol></blockquote><p>常用术语：  </p><blockquote><p>消息：传送的信息<br>数据：消息的实体，即用特定方式表示的信息<br>信号：数据的电气或者电磁表现  可以分为两类：<strong>模拟信号</strong>和<strong>数字信号</strong><br><strong>码元</strong>：使用时域的波形表示数字信号（离散信号）时，代表不同离散数值的基本波形。</p></blockquote><p><strong>2）信道的基本概念</strong><br><strong>信道</strong>：向某一个方向传送信息的媒体。<br>三种形式：</p><blockquote><p><strong>单向信道</strong>：一方发送，一方接收<br><strong>双向交替信道</strong>：双方都可发送消息，但不能同时进行  <strong>单工</strong><br><strong>双向同时信道</strong>：双方可同时发送信息  </p></blockquote><p><strong>基带信号</strong>（基本频带信号）：<strong>来自信源的信号</strong>。包含较多<em>低频分量</em>甚至<em>直流分量</em>（许多信道不能传输）<br><strong>调制</strong>：<em>将来自源信号的低频甚至直流信号进行变换</em>，使得这种低频直流信号可以便于在信道内传输  </p><blockquote><p>两种调制方法：</p></blockquote><blockquote><p><strong>基带调制</strong>： 把数字信号转换为另一种形式的数字信号，即<em>仅对信号的波形进行变换</em>，可称之为<strong>编码</strong>调制<br><img src="https://img-blog.csdn.net/20180918172905582?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDY4MTMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="|500">不归零制：<strong>电平正负</strong>分别表示1、0<br>归零制：<strong>正负脉冲</strong>分别表示1、0<br>曼彻斯特编码：周期<strong>中心跳动方向</strong>上和下分别为0、1<br>差分曼彻斯特编码：每一位中心都有跳变。<strong>位开始边界有无跳变</strong>分别表示0、1</p></blockquote><blockquote><p><strong>带通调制</strong>：使用<strong>载波</strong>进行调制，<em>将基带信号的频率般到高频段，并将之转换为模拟信号</em>，此时信号也称<strong>带通信号</strong>。<br><img src="https://img-blog.csdn.net/20180918172947184?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDY4MTMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="|500"><br>调幅：<strong>有无载波</strong>分对应0、1<br>调频：<strong>不同频率</strong>区分0、1<br>调相：<strong>初始相位</strong>0和180对应0、1<br><strong>正交振幅调制</strong></p></blockquote><p><strong>3）信道极限容量</strong><br>一定的失真不影响数字通信。但要避免失真严重<br>（码元速率过高、信号传输距离过远、噪声干扰大、传输媒体质量低）</p><ul><li>码元在信道上的传输速率</li></ul><ol><li>信道所能通过的频率范围<blockquote><p><strong>码间串扰</strong>：信道传输的频率范围有限，导致高频分量衰减，码元拖影导致码元之间界限模糊。<br><em>奈氏准则</em>：每赫带宽的理想低通信道的最高码元传输速率V是每秒2个码元.$$V&#x3D;2W$$</p></blockquote></li><li>信噪比<blockquote><p>噪声对信号的影响是相对的，信号越强，影响越小，因此考虑信噪比。<br>$信噪比(dB) &#x3D; 10 log_{10}(S&#x2F;N)(dB)$<br><em>香农公式</em>：信道<strong>极限</strong>传输速率C,信道带宽W,信噪比S&#x2F;N$$C&#x3D;Wlog_{2}(1+S&#x2F;N)(bit&#x2F;s)$$ <strong>带宽和信噪比越高，信息传输速率上限越高</strong></p></blockquote></li></ol><p>增加每个码元携带的信息量可以提高信息传输速率，但一个码元表示比特越多，抗干扰要求越高。</p><h3 id="物理层下面的传输媒体："><a href="#物理层下面的传输媒体：" class="headerlink" title="物理层下面的传输媒体："></a>物理层下面的传输媒体：</h3><blockquote><p>引导性传输媒体：双绞线，同轴电缆，光缆，<br>非引导型传输媒体：即无线传输</p></blockquote><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><p><strong>复用</strong>：发送端使用一个复用器，接收端使用分用器，使用共享信道。<br>![[Pasted image 20230308112649.png|350]]<br><strong>频分复用FDM</strong></p><blockquote><p>用户在同样的时间内<em>占用不同的频率带宽</em>而复用同一个信道   <br>![[Pasted image 20230315095021.png|400]]</p></blockquote><p><strong>时分复用TDM</strong></p><blockquote><p>将时间划分为相同的时分复用帧TDM，<em>在不同的时间占用相同的频带宽度</em>，利于数字信号。由于时分复用会在用户间不断切换，所以不使用的用户也会占用，使用的只占用一部分。<strong>利用率不高</strong><br>![[Pasted image 20230315095047.png|400]]</p></blockquote><p><strong>统计时分复用STDM</strong> </p><blockquote><p>改进的时分复用，按需动态分配时隙，而不是固定分配时隙 （每个STMD帧的时隙数小于连接在<em>集中器</em>上的用户数，使得<strong>每次传送的STDM帧中的分组都是满的</strong>。又称<em>异步时分复用</em>。由于信息顺序打乱不可预知，<strong>每个STDM前端一部分存放用户地址</strong>，用来判别对应的用户。<br>![[Pasted image 20230308120657.png|350]]</p></blockquote><p><strong>波分复用WDM</strong></p><blockquote><p>光的频分复用，利用在光线技术通信中；光频率高，所以采用波长区分。<br>复用器:<strong>合波器</strong>。分用器：<strong>分波器</strong>。<br><strong>密集波分复用</strong>，复用器：<strong>光复用器</strong>，分用器：<strong>光分用器</strong><br>![[Pasted image 20230315101822.png|400]]</p></blockquote><p><strong>码分复用CDM</strong></p><blockquote><p>每个用户在相同的时间使用相同的频带进行通信，但各用户使用经过挑选的<strong>不同码型</strong>，从而使得个用户之间可以进行独立的通信.<br><strong>码片</strong>：1bit的时间进一步划分。占用的频率带宽提高，<strong>扩频</strong>。<br><strong>码片序列</strong>：序列自身代表1，反码代表0；不同站点间码片序列<strong>规格化内积</strong>为0，同序列或者反码<strong>规格化内积</strong>分别为1和-1；<br>![[Pasted image 20230315101845.png|400]]</p></blockquote><h3 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h3><h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><p>宽带：将用户连接到某个ISP以获取上网所需的IP地址。<br><strong>有线宽带接入</strong>——ADSL技术和FTTX技术<br><strong>无线宽带接入</strong><br>非对称数字用户线ADSL：对现有模拟电话的用户线改造<br>非对称数字用户线ASDL技术是用数字技术对现有的模拟电话用户线进行改造，使其能够承载宽带业务的一种技术；<br>光纤同轴混合网HFC在有线电视网的基础上开发的<br>光纤到户技术FTTH</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/19/hello-world/"/>
      <url>/2023/03/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>视频</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
